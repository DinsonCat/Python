{"./":{"url":"./","title":"INTRODUCE","keywords":"","body":" "},"primary/ren-shi-python-he-ji-chu-zhi-shi/ren-shi-python-le-89e329.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/ren-shi-python-le-89e329.html","title":"认识python(了解)","keywords":"","body":"认识python(了解) 1. Python发展历史 2. Python优缺点 优点 缺点 3. Python应用场景 认识python(了解) 1. Python发展历史 起源 Python的作者，Guido von Rossum，荷兰人。1982年，Guido从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。 在那个时候，Guido接触并使用过诸如Pascal、C、Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。 这种编程方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。 Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的数学和计算机研究所开发的。Guido在该研究所工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词的总数： HOW TO RETURN words document: PUT {} IN collection FOR line IN document: FOR word IN split line: IF word not.in collection: INSERT word IN collection RETURN collection HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号和缩进来表示程序块。行 尾没有分号。for和if结构中也没有括号() 。赋值采用的是PUT，而不是更常见的等号。这些改动让ABC程序读起来像一段文字。 尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题： 可拓展性差。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。 不能直接进行IO。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文 件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？ 过度革新。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO 。然而对于程序员来说，他们更习惯 用function或者define来定义一个函数。同样，程序员更习惯用等号来分配变量。尽管ABC语言很特别，但学习难度 也很大。 传播困难。ABC编译器很大，必须被保存在磁带上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编 译器。 这样，ABC语言就很难快速传播。 1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python's Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。Guido作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的hacking行为。 一门语言的诞生 1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了 ：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。 Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。 但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例，特别是C语言的惯例，比如回归等号赋值。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。 Python从一开始就特别在意可拓展性。Python可以在多个层次上拓展。从高层上，你可以直接引入. py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写. py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更 改。 最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python。随后，Python拓 展到研究所之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程 序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。这一特征吸引了广大的程序员。Python开始流行。 人生苦短，我用python 时势造英雄 我们不得不暂停我们的Python时间，转而看一看瞬息万变的计算机行业。1990年代初，个人计算机开始进入普通家庭。Intel发布了486处理器，windows发布window 3.0开始的一系列视窗系统。计算机的性能大大提高。程序员开始关注计算机的易用性，比如图形化界面。 Windows 3.0 由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件厂商甚至渴望高需求软 件的出现，以带动硬件的更新换代。C++和Java相继流行。C++和Java提供了面向对象的编程范式，以及丰富的对象库。在牺牲了一定的性能的代价下，C++和Java大大提高了程序的产量。语言的易用性被提到一个新的高度。我们还记得 ，ABC失败的一个重要原因是硬件的性能限制。从这方面说，Python要比ABC幸运许多。 另一个悄然发生的改变是Internet。1990年代还是个人电脑的时代，windows和Intel挟PC以令天下，盛极一时。尽管Internet为主体的信息革命尚未到来，但许多程序员以及资深计算机用户已经在频繁使用Internet进行交流，比如 使用email和newsgroup。Internet让信息交流成本大大下降。一种新的软件开发模式开始流行：开源。程序员利用 业余时间进行软件开发，并开放源代码。1991年，Linus在comp.os.minix新闻组上发布了Linux内核源代码，吸引大批hacker的加入。Linux和GNU相互合作，最终构成了一个充满活力的开源平台。 硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容 易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Gu ido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。由于Guido至高无上的决定权，他因此被称为“终身的仁慈独裁者”。 Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达是参考Perl，而lambda, map, filter, reduce等函数参考了Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社 区不断扩大，进而拥有了自己的newsgroup，网站，以及基金。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。 到今天，Python的框架已经确立。Python语言以对象为核心组织代码，支持多种编程范式，采用动态类型，自动进行内存回收。Python支持解释运行，并能调用C库进行拓展。Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django、web.py、wxpython、numpy、matplotlib、PIL，将Python升级成了物种丰富的热带雨林。 启示录 Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。Python在TIOBE排行榜中排行第八，它是Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言。Python的发展史可以作为一个代表，带给我许多启示。 在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。 Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他 语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评 判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。其实，以开放的心态来接受各个语言，说不定哪一天，程序员也可以如Guido那样，混合出自己的语言。 关键点常识 Python的发音与拼写 Python的意思是蟒蛇，源于作者喜欢的一部电视剧 (C呢？) Python的作者是Guido van Rossum（龟叔） Python是龟叔在1989年圣诞节期间，为了打发无聊的圣诞节而用C编写的一个编程语言 Python正式诞生于1991年 Python的解释器如今有多个语言实现，我们常用的是CPython（官方版本的C语言实现），其他还有Jython（可以运行在Java平台）、IronPython（可以运行在.NET和Mono平台）、PyPy（Python实现的，支持JIT即时编译） Python目前有两个版本，Python2和Python3，最新版分别为2.7.12和3.5.2，现阶段大部分公司用的是Python2 Life is shot, you need Python. 人生苦短，我用Python。 2017年1月份 编程语言流行排行榜 2. Python优缺点 优点 简单————Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。 易学————就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。 免费、开源————Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什么Python如此优秀的原因之一——它是由一群希望看到一个更加优秀的Python的人创造并经常改进着的。 高层语言————当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。 可移植性————由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行。这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC、Symbian以及Google基于linux开发的Android平台！ 解释性————这一点需要一些解释。一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。 面向对象————Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。 可扩展性————如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。 丰富的库————Python标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。 规范的代码————Python采用强制缩进的方式使得代码具有极佳的可读性。 缺点 运行速度，有速度要求的话，用C++改写关键部分吧。 国内市场较小（国内以python来做主要开发的，目前只有一些web2.0公司）。但时间推移，目前很多国内软件公司，尤其是游戏公司，也开始规模使用他。 中文资料匮乏（好的python中文资料屈指可数）。托社区的福，有几本优秀的教材已经被翻译了，但入门级教材多，高级内容还是只能看英语版。 构架选择太多（没有像C#这样的官方.net构架，也没有像ruby由于历史较短，构架开发的相对集中。Ruby on Rails 构架开发中小型web程序天下无敌）。不过这也从另一个侧面说明，python比较优秀，吸引的人才多，项目也多。 3. Python应用场景 Web应用开发 Python经常被用于Web开发。比如，通过mod_wsgi模块，Apache可以运行用Python编写的Web程序。Python定义了WSGI标准应用接口来协调Http服务器与基于Python的Web程序之间的通信。一些Web框架，如Django,TurboGears,web2py,Zope等，可以让程序员轻松地开发和管理复杂的Web程序。 操作系统管理、服务器运维的自动化脚本 在很多操作系统里，Python是标准的系统组件。 大多数Linux发行版以及NetBSD、OpenBSD和Mac OS X都集成了Python，可以在终端下直接运行Python。有一些Linux发行版的安装器使用Python语言编写，比如Ubuntu的Ubiquity安装器,Red Hat Linux和Fedora的Anaconda安装器。Gentoo Linux使用Python来编写它的Portage包管理系统。Python标准库包含了多个调用操作系统功能的库。通过pywin32这个第三方软件 包，Python能够访问Windows的COM服务及其它Windows API。使用IronPython，Python程序能够直接调用.Net Framework。一般说来，Python编写的系统管理脚本在可读性、性能、代码重用度、扩展性几方面都优于普通的shell脚本。 科学计算 NumPy,SciPy,Matplotlib可以让Python程序员编写科学计算程序。 桌面软件 PyQt、PySide、wxPython、PyGTK是Python快速开发桌面应用程序的利器。 服务器软件（网络软件） Python对于各种网络协议的支持很完善，因此经常被用于编写服务器软件、网络爬虫。第三方库Twisted支持异步网络编程和多数标准的网络协议(包含客户端和服务器)，并且提供了多种工具，被广泛用于编写高性能的服务器软件。 游戏 很多游戏使用C++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小；而Python则支持更多的特性和数据类型。 构思实现，产品早期原型和迭代 YouTube、Google、Yahoo!、NASA都在内部大量地使用Python。 "},"primary/ren-shi-python-he-ji-chu-zhi-shi/di-yi-ge-python-cheng-xu.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/di-yi-ge-python-cheng-xu.html","title":"第一个Python程序","keywords":"","body":"编写第一个python程序 编写python程序方法1 编写python程序方法2 另外一种运行python的程序的方法 练一练 小总结 编写第一个python程序 编写python程序方法1 打开“超级终端” 输入 python3 ，输入python3表示用的python这门编程语言的第3个版本，如果只输入python的话表示用的是python的第2个版本 输入以下代码 print('hello world') 编写python程序方法2 打开编辑软件sublime 把以下代码，编写如下代码 保存代码 运行程序 另外一种运行python的程序的方法 在代码第一行写入执行时的python解释器路径，编辑完后需要对此python文件添加'x'权限 练一练 要求：编写一个程序，输出itcast.cn 小总结 对于编写python程序，上面有3种方法，那到实际开发中哪一种用的比较多呢？一般是用第2或者第3种，即保存在xxx.py文件中，这样可以直接下一次执行运行；而如果用第一种方法的话，每一次运行程序都需要重新进行输入，费时费力 "},"primary/ren-shi-python-he-ji-chu-zhi-shi/zhu-shi.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/zhu-shi.html","title":"注释","keywords":"","body":"注释的引入 看以下程序示例（未使用注释） 看以下程序示例（使用注释） 小总结（注释的作用） 注释的分类 单行注释 多行注释 python程序中，中文支持 注释的引入 看以下程序示例（未使用注释） 看以下程序示例（使用注释） 小总结（注释的作用） 通过用自己熟悉的语言，在程序中对某些代码进行标注说明，这就是注释的作用，能够大大增强程序的可读性 注释的分类 单行注释 以#开头，#右边的所有东西当做说明，而不是真正要执行的程序，起辅助说明作用 # 我是注释，可以在里写一些功能说明之类的哦 print('hello world') 多行注释 '''我是多行注释，可以写很多很多行的功能说明 这就是我牛X指出 哈哈哈。。。 ''' ''' 下面的代码完成 ，打印一首诗 名字叫做：春江花月夜 作者，忘了 ''' print('╔═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╗') print('║　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│ ║') print('║　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　║') print('║　│春│滟│江│空│江│江│人│不│白│谁│可│玉│此│鸿│昨│江│斜│不│　║') print('║　│江│滟│流│里│天│畔│生│知│云│家│怜│户│时│雁│夜│水│月│知│　║') print('║　│潮│随│宛│流│一│何│代│江│一│今│楼│帘│相│长│闲│流│沉│乘│　║') print('║　│水│波│转│霜│色│人│代│月│片│夜│上│中│望│飞│潭│春│沉│月│　║') print('║　│连│千│绕│不│无│初│无│待│去│扁│月│卷│不│光│梦│去│藏│几│　║') print('║春│海│万│芳│觉│纤│见│穷│何│悠│舟│徘│不│相│不│落│欲│海│人│　║') print('║江│平│里│甸│飞│尘│月│已│人│悠│子│徊│去│闻│度│花│尽│雾│归│　║') print('║花│，│，│，│，│，│，│，│，│，│，│，│，│，│，│，│，│，│，│　║') print('║月│海│何│月│汀│皎│江│江│但│青│何│应│捣│愿│鱼│可│江│碣│落│　║') print('║夜│上│处│照│上│皎│月│月│见│枫│处│照│衣│逐│龙│怜│潭│石│月│　║') print('║　│明│春│花│白│空│何│年│长│浦│相│离│砧│月│潜│春│落│潇│摇│　║') print('║　│月│江│林│沙│中│年│年│江│上│思│人│上│华│跃│半│月│湘│情│　║') print('║　│共│无│皆│看│孤│初│望│送│不│明│妆│拂│流│水│不│复│无│满│　║') print('║　│潮│月│似│不│月│照│相│流│胜│月│镜│还│照│成│还│西│限│江│　║') print('║　│生│明│霰│见│轮│人│似│水│愁│楼│台│来│君│文│家│斜│路│树│　║') print('║　│。│。│。│。│。│？│。│。│。│？│。│。│。│。│。│。│。│。│　║') print('║　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　║') print('║　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　│　║') print('╚═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╧═╝') python程序中，中文支持 如果直接在程序中用到了中文，比如 print('你好') 如果直接运行输出，程序会出错： 解决的办法为：在程序的开头写入如下代码，这就是中文注释 #coding=utf-8 修改之后的程序: #coding=utf-8 print('你好') 运行结果: 你好 注意： 在python的语法规范中推荐使用的方式： # -*- coding:utf-8 -*- "},"primary/ren-shi-python-he-ji-chu-zhi-shi/bian-liang.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/bian-liang.html","title":"变量","keywords":"","body":"变量以及类型 变量的定义 变量的类型 变量以及类型 变量的定义 在程序中，有时我们需要对2个数据进行求和，那么该怎样做呢？ 大家类比一下现实生活中，比如去超市买东西，往往咱们需要一个菜篮子，用来进行存储物品，等到所有的物品都购买完成后，在收银台进行结账即可 如果在程序中，需要把2个数据，或者多个数据进行求和的话，那么就需要把这些数据先存储起来，然后把它们累加起来即可 在Python中，存储一个数据，需要一个叫做变量的东西，如下示例: num1 = 100 #num1就是一个变量，就好一个小菜篮子 num2 = 87 #num2也是一个变量 result = num1 + num2 #把num1和num2这两个\"菜篮子\"中的数据进行累加，然后放到 result变量中 说明: 所谓变量，可以理解为 菜篮子 ，如果需要存储多个数据，最简单的方式是有多个变量，当然了也可以使用一个 程序就是用来处理数据的，而变量就是用来存储数据的 想一想：我们应该让变量占用多大的空间，保存什么样的数据？ 变量的类型 生活中的“类型”的例子: 程序中: 为了更充分的利用内存空间以及更有效率的管理内存，变量是有不同的类型的，如下所示: 怎样知道一个变量的类型呢？ 在python中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了，不需要咱们开发者主动的去说明它的类型，系统会自动辨别 可以使用type(变量的名字)，来查看变量的类型 "},"primary/ren-shi-python-he-ji-chu-zhi-shi/biao-shi-fu-he-guan-jian-zi.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/biao-shi-fu-he-guan-jian-zi.html","title":"标示符和关键字","keywords":"","body":"标示符和关键字 标示符 标示符的规则 命名规则 关键字 标示符和关键字 标示符 什么是标示符，看下图: 开发人员在程序中自定义的一些符号和名称 标示符是自己定义的,如变量名 、函数名等 标示符的规则 标示符由字母、下划线和数字组成，且数字不能开头 思考：下面的标示符哪些是正确的，哪些不正确为什么 fromNo12 from#12 my_Boolean my-Boolean Obj2 2ndObj myInt test1 Mike2jack My_tExt _test test!32 haha(da)tt int jack_rose jack&rose GUI G.U.I python中的标识符是区分大小写的 命名规则 见名知意 起一个有意义的名字，尽量做到看一眼就知道是什么意思(提高代码可 读性) 比如: 名字 就定义为 name , 定义学生 用 student 驼峰命名法 小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog 大驼峰式命名法（upper camel case）： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName 不过在程序员中还有一种命名法比较流行，就是用下划线“_”来连接所有的单词，比如send_buf 关键字 什么是关键字 python一些具有特殊功能的标示符，这就是所谓的关键字 关键字，是python已经使用的了，所以不允许开发者自己定义和关键字相同的名字的标示符 查看关键字: and as assert break class continue def del elif else except exec finally for from global if in import is lambda not or pass print raise return try while with yield 可以通过以下命令进行查看当前系统中python的关键字 关键字的学习以及使用，咱们会在后面的课程中依依进行学习 "},"primary/ren-shi-python-he-ji-chu-zhi-shi/shu-chu.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/shu-chu.html","title":"输出/输出","keywords":"","body":"输出 普通的输出 格式化输出 格式化操作的目的 什么是格式化 常用的格式符号 换行输出 练一练 输入 python2版本中 raw_input() input() python3版本中 输出 普通的输出 生活中的“输出” 软件中的“输出” python中变量的输出 # 打印提示 print('hello world') print('给我的卡---印度语，你好的意思') 格式化输出 格式化操作的目的 比如有以下代码: pirnt(\"我今年10岁\") pirnt(\"我今年11岁\") pirnt(\"我今年12岁\") ... 想一想: 在输出年龄的时候，用了多次\"我今年xx岁\"，能否简化一下程序呢？？？ 答: 字符串格式化 什么是格式化 看如下代码: pirnt(\"我今年10岁\") pirnt(\"我今年11岁\") pirnt(\"我今年12岁\") ... 在程序中，看到了%这样的操作符，这就是Python中格式化输出。 age = 18 name = \"xiaohua\" print(\"我的姓名是%s,年龄是%d\"%(name,age)) 常用的格式符号 下面是完整的，它可以与％符号使用列表: 格式符号 转换 %c 字符 %s 通过str() 字符串转换来格式化 %i 有符号十进制整数 %d 有符号十进制整数 %u 无符号十进制整数 %o 八进制整数 %x 十六进制整数（小写字母） %X 十六进制整数（大写字母） %e 索引符号（小写'e'） %E 索引符号（大写“E”） %f 浮点实数 %g ％f和％e 的简写 %G ％f和％E的简写 换行输出 在输出的时候，如果有\\n那么，此时\\n后的内容会在另外一行显示 print(\"1234567890-------\") # 会在一行显示 print(\"1234567890\\n-------\") # 一行显示1234567890，另外一行显示------- 练一练 编写代码完成以下名片的显示 ================================== 姓名: dongGe QQ:xxxxxxx 手机号:131xxxxxx 公司地址:北京市xxxx ================================== 输入 python2版本中 咱们在银行ATM机器前取钱时，肯定需要输入密码，对不？ 那么怎样才能让程序知道咱们刚刚输入的是什么呢？？ 大家应该知道了，如果要完成ATM机取钱这件事情，需要先从键盘中输入一个数据，然后用一个变量来保存，是不是很好理解啊 raw_input() 在Python中，获取键盘输入的数据的方法是采用 raw_input 函数（至于什么是函数，咱们以后的章节中讲解），那么这个 raw_input 怎么用呢? 看如下示例: password = raw_input(\"请输入密码:\") print '您刚刚输入的密码是:', password 运行结果: 请输入密码:123456 您刚刚输入的密码是:123456 注意: raw_input()的小括号中放入的是，提示信息，用来在获取数据之前给用户的一个简单提示 raw_input()在从键盘获取了数据以后，会存放到等号右边的变量中 raw_input()会把用户输入的任何值都作为字符串来对待 input() input()函数与raw_input()类似，但其接受的输入必须是表达式。 >>> a = input() 123 >>> a 123 >>> type(a) >>> a = input() abc Traceback (most recent call last): File \"\", line 1, in File \"\", line 1, in NameError: name 'abc' is not defined >>> a = input() \"abc\" >>> a 'abc' >>> type(a) >>> a = input() 1+3 >>> a 4 >>> a = input() \"abc\"+\"def\" >>> a 'abcdef' >>> value = 100 >>> a = input() value >>> a 100 input()接受表达式输入，并把表达式的结果赋值给等号左边的变量 python3版本中 没有raw_input()函数，只有input() 并且 python3中的input与python2中的raw_input()功能一样 "},"primary/ren-shi-python-he-ji-chu-zhi-shi/yun-suan-fu.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/yun-suan-fu.html","title":"运算符","keywords":"","body":"运算符 运算符 python支持以下几种运算符 算术运算符 下面以a=10 ,b=20为例进行计算 运算符 描述 实例 + 加 两个对象相加 a + b 输出结果 30 - 减 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 x除以y b / a 输出结果 2 // 取整除 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 % 取余 返回除法的余数 b % a 输出结果 0 ** 幂 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 >>> 9/2.0 4.5 >>> 9//2.0 4.0 赋值运算符 运算符 描述 实例 = 赋值运算符 把=号右边的结果给左边的变量 num=1+2*3 结果num的值为7 >>> a, b = 1, 2 >>> a 1 >>> b 2 复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a "},"primary/ren-shi-python-he-ji-chu-zhi-shi/chang-yong-de-shu-ju-lei-xing-zhuan-huan.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/chang-yong-de-shu-ju-lei-xing-zhuan-huan.html","title":"常用的数据类型转换","keywords":"","body":"常用的数据类型转换 举例 常用的数据类型转换 函数 说明 int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 举例 a = '100' # 此时a的类型是一个字符串，里面存放了100这3个字符 b = int(a) # 此时b的类型是整型，里面存放的是数字100 print(\"a=%d\"%b) "},"primary/ren-shi-python-he-ji-chu-zhi-shi/ifpan-duan-yu-ju.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/ifpan-duan-yu-ju.html","title":"if判断语句","keywords":"","body":"if判断语句 if判断语句介绍 练一练 想一想 if判断语句 if判断语句介绍 if语句是用来进行判断的，其使用格式如下： if 要判断的条件: 条件成立时，要做的事情 demo1: age = 30 print \"------if判断开始------\" if age>=18: print \"我已经成年了\" print \"------if判断结束------\" 运行结果: ------if判断开始------ 我已经成年了 ------if判断结束------ demo2: ------if判断开始------ 我已经成年了 ------if判断结束------ 运行结果: ------if判断开始------ ------if判断结束------ 小总结： 以上2个demo仅仅是age变量的值不一样，结果却不同；能够看得出if判断语句的作用：就是当满足一定条件时才会执行那块代码，否则就不执行那块代码 注意： 代码的缩进为一个tab键，或者4个空格 练一练 要求：从键盘获取自己的年龄，判断是否大于或者等于18岁，如果满足就输出“哥，已成年，网吧可以去了” 使用input从键盘中获取数据，并且存入到一个变量中 使用if语句，来判断 age>=18是否成立 想一想 判断age大于或者等于18岁，使用的是 >=，还有哪些呢？ "},"primary/ren-shi-python-he-ji-chu-zhi-shi/bi-8f8328-ji-guan-7cfb29-yun-suan-fu.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/bi-8f8328-ji-guan-7cfb29-yun-suan-fu.html","title":"比较(即关系)运算符","keywords":"","body":" 比较(即关系)运算符 逻辑运算符 比较(即关系)运算符 python中的比较运算符如下表 运算符 描述 示例 == 检查两个操作数的值是否相等，如果是则条件变为真。 如a=3,b=3则（a == b) 为 true. != 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a != b) 为 true. <> 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a <> b) 为 true。这个类似于 != 运算符 > 检查左操作数的值是否大于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a > b) 为 true. 检查左操作数的值是否小于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a >= 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a >= b) 为 true. 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔\"与\" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔\"或\" - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔\"非\" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False "},"primary/ren-shi-python-he-ji-chu-zhi-shi/zuo-ye.html":{"url":"primary/ren-shi-python-he-ji-chu-zhi-shi/zuo-ye.html","title":"作业","keywords":"","body":"必做题： 1. 说出变量名字，可以由哪些字符组成 2. 写出变量命名时的规则 3. 说出什么是驼峰法（大驼峰、小驼峰） 4. 编写程序，完成以下要求： 提示用户进行输入数据 获取用户的数据数据（需要获取2个） 对获取的两个数字进行求和运行，并输出相应的结果 5. 编写程序，完成以下要求： 提示用户进行输入数据 获取用户的数据数据（需要获取2个） 对获取的两个数字进行减法运行，并输出相应的结果 6. 编写程序，完成以下信息的显示: ================================== = 欢迎进入到身份认证系统V1.0 = 1. 登录 = 2. 退出 = 3. 认证 = 4. 修改密码 ================================== 7. 编写程序，从键盘获取一个人的信息，然后按照下面格式显示 ================================== 姓名: dongGe QQ:xxxxxxx 手机号:131xxxxxx 公司地址:北京市xxxx ================================== 8. 编写程序，从键盘获取用户名和密码，然后判断，如果正确就输出以下信息 亲爱的xxx，欢迎登陆 爱学习管理系统 "},"primary/pan-duan-yu-ju-he-xun-huan-yu-ju/if-else.html":{"url":"primary/pan-duan-yu-ju-he-xun-huan-yu-ju/if-else.html","title":"if-else","keywords":"","body":"if-else if-else的使用格式 练一练 elif elif的功能 注意点 if嵌套 if嵌套的格式 if嵌套的应用 练一练 if-else 想一想：在使用if的时候，它只能做到满足条件时要做的事情。那万一需要在不满足条件的时候，做某些事，该怎么办呢？ 答：else if-else的使用格式 if 条件: 满足条件时要做的事情1 满足条件时要做的事情2 满足条件时要做的事情3 ...(省略)... else: 不满足条件时要做的事情1 不满足条件时要做的事情2 不满足条件时要做的事情3 ...(省略)... demo1 chePiao = 1 # 用1代表有车票，0代表没有车票 if chePiao == 1: print(\"有车票，可以上火车\") print(\"终于可以见到Ta了，美滋滋~~~\") else: print(\"没有车票，不能上车\") print(\"亲爱的，那就下次见了，一票难求啊~~~~(>_ 结果1：有车票的情况 有车票，可以上火车 终于可以见到Ta了，美滋滋~~ 结果2：没有车票的情况 没有车票，不能上课 亲爱的，那就下次见了，一票难求啊~~~~(>_练一练 要求：从键盘输入刀子的长度，如果刀子长度没有超过10cm，则允许上火车，否则不允许上火车 elif 想一想: if能完成当xxx时做事情 if-else能完成当xxx时做事情1，否则做事情2 如果有这样一种情况：当xxx1时做事情1，当xxx2时做事情2，当xxx3时做事情3，那该怎么实现呢？ 答: elif elif的功能 elif的使用格式如下: if xxx1: 事情1 elif xxx2: 事情2 elif xxx3: 事情3 说明: 当xxx1满足时，执行事情1，然后整个if结束 当xxx1不满足时，那么判断xxx2，如果xxx2满足，则执行事情2，然后整个if结束 当xxx1不满足时，xxx2也不满足，如果xxx3满足，则执行事情3，然后整个if结束 demo: score = 77 if score>=90 and score=80 and score=70 and score=60 and score=0 and score 注意点 可以和else一起使用 if 性别为男性: 输出男性的特征 ... elif 性别为女性: 输出女性的特征 ... else: 第三种性别的特征 ... 说明: 当 “性别为男性” 满足时，执行 “输出男性的特征”的相关代码 当 “性别为男性” 不满足时，如果 “性别为女性”满足，则执行 “输出女性的特征”的相关代码 当 “性别为男性” 不满足，“性别为女性”也不满足，那么久默认执行else后面的代码，即 “第三种性别的特征”相关代码 elif必须和if一起使用，否则出错 if嵌套 通过学习if的基本用法，已经知道了 当需要满足条件去做事情的这种情况需要使用if 当满足条件时做事情A，不满足条件做事情B的这种情况使用if-else 想一想： 坐火车或者地铁的实际情况是：先进行安检如果安检通过才会判断是否有车票，或者是先检查是否有车票之后才会进行安检，即实际的情况某个判断是再另外一个判断成立的基础上进行的，这样的情况该怎样解决呢？ 答： if嵌套 if嵌套的格式 if 条件1: 满足条件1 做的事情1 满足条件1 做的事情2 ...(省略)... if 条件2: 满足条件2 做的事情1 满足条件2 做的事情2 ...(省略)... 说明 外层的if判断，也可以是if-else 内层的if判断，也可以是if-else 根据实际开发的情况，进行选择 if嵌套的应用 demo： chePiao = 1 # 用1代表有车票，0代表没有车票 daoLenght = 9 # 刀子的长度，单位为cm if chePiao == 1: print(\"有车票，可以进站\") if daoLenght _ 结果1：chePiao = 1;daoLenght = 9 有车票，可以进站 通过安检 终于可以见到Ta了，美滋滋~~~ 结果2：chePiao = 1;daoLenght = 20 有车票，可以进站 没有通过安检 刀子的长度超过规定，等待警察处理... 结果3：chePiao = 0;daoLenght = 9 没有车票，不能进站 亲爱的，那就下次见了，一票难求啊~~~~(>_ 结果4：chePiao = 0;daoLenght = 20 没有车票，不能进站 亲爱的，那就下次见了，一票难求啊~~~~(>_ 想一想:为什么结果3和结果4相同？？？ 练一练 情节描述：上公交车，并且可以有座位坐下 要求：输入公交卡当前的余额，只要超过2元，就可以上公交车；如果空座位的数量大于0，就可以坐下 "},"primary/pan-duan-yu-ju-he-xun-huan-yu-ju/elif.html":{"url":"primary/pan-duan-yu-ju-he-xun-huan-yu-ju/elif.html","title":"while循环","keywords":"","body":"while循环 while循环的格式 while循环应用 计算1~100的累积和（包含1和100） 计算1~100之间偶数的累积和（包含1和100） while循环嵌套 while嵌套的格式 while嵌套应用一 while嵌套应用二：九九乘法表 while循环 while循环的格式 while 条件: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... demo i = 0 while i 结果: 当前是第1次执行循环 i=0 当前是第2次执行循环 i=1 当前是第3次执行循环 i=2 当前是第4次执行循环 i=3 当前是第5次执行循环 i=4 while循环应用 计算1~100的累积和（包含1和100） 参考代码如下: #encoding=utf-8 i = 1 sum = 0 while i 计算1~100之间偶数的累积和（包含1和100） 参考代码如下: #encoding=utf-8 i = 1 sum = 0 while i while循环嵌套 前面学习过if的嵌套了，想一想if嵌套是什么样子的？ 类似if的嵌套，while嵌套就是：while里面还有while while嵌套的格式 while 条件1: 条件1满足时，做的事情1 条件1满足时，做的事情2 条件1满足时，做的事情3 ...(省略)... while 条件2: 条件2满足时，做的事情1 条件2满足时，做的事情2 条件2满足时，做的事情3 ...(省略)... while嵌套应用一 要求：打印如下图形： * * * * * * * * * * * * * * * 参考代码： i = 1 while iwhile嵌套应用二：九九乘法表 参考代码： i = 1 while i"},"primary/pan-duan-yu-ju-he-xun-huan-yu-ju/forxun-huan.html":{"url":"primary/pan-duan-yu-ju-he-xun-huan-yu-ju/forxun-huan.html","title":"for循环","keywords":"","body":"for循环 for循环的格式 demo1 demo2 break和continue break for循环 while循环 小总结: continue for循环 while循环 注意点 for循环 像while循环一样，for可以完成循环的功能。 在Python中 for循环可以遍历任何序列的项目，如一个列表或者一个字符串等。 for循环的格式 for 临时变量 in 列表或者字符串等: 循环满足条件时执行的代码 else: 循环不满足条件时执行的代码 demo1 name = 'dongGe' for x in name: print(x) 运行结果如下: demo2 name = '' for x in name: print(x) else: print(\"没有数据\") 运行结果如下: break和continue break for循环 普通的循环示例如下： name = 'dongGe' for x in name: print('----') print(x) 运行结果: 带有break的循环示例如下: name = 'dongGe' for x in name: print('----') if x == 'g': break print(x) 运行结果: while循环 普通的循环示例如下： i = 0 while i 运行结果: 带有break的循环示例如下: i = 0 while i 运行结果: 小总结: break的作用：用来结束整个循环 continue for循环 带有continue的循环示例如下: name = 'dongGe' for x in name: print('----') if x == 'g': continue print(x) 运行结果: while循环 带有continue的循环示例如下: i = 0 while i 运行结果: 小总结: continue的作用：用来结束本次循环，紧接着执行下一次的循环 注意点 break/continue只能用在循环中，除此以外不能单独使用 break/continue在嵌套循环中，只对最近的一层循环起作用 "},"primary/pan-duan-yu-ju-he-xun-huan-yu-ju/zong-jie.html":{"url":"primary/pan-duan-yu-ju-he-xun-huan-yu-ju/zong-jie.html","title":"总结","keywords":"","body":"总结 总结 if往往用来对条件是否满足进行判断 if有4中基本的使用方法： 基本方法 if 条件: 满足时做的事情 满足与否执行不同的事情 if 条件: 满足时做的事情 else: 不满足时做的事情 多个条件的判断 if 条件: 满足时做的事情 elif 条件2: 满足条件2时做的事情 elif 条件3: 满足条件3时做的事情 else: 条件都不满足时做的事情 嵌套 if 条件: 满足时做的事情 这里还可以放入其他任何形式的if判断语句 while循环一般通过数值是否满足来确定循环的条件 i = 0 while i for循环一般是对能保存多个数据的变量，进行便利 name = 'dongGe' for x in name: print(x) if、while、for等其他语句可以随意组合，这样往往就完成了复杂的功能 "},"primary/pan-duan-yu-ju-he-xun-huan-yu-ju/zuo-ye.html":{"url":"primary/pan-duan-yu-ju-he-xun-huan-yu-ju/zuo-ye.html","title":"作业","keywords":"","body":"必做题： 使用if，编写程序，实现以下功能： 从键盘获取用户名、密码 如果用户名和密码都正确（预先设定一个用户名和密码），那么就显示“欢迎进入xxx的世界”，否则提示密码或者用户名错误 使用while，完成以下图形的输出 * * * * * * * * * * * * * * * * * * * * * * * * * 选做题： 根据以下信息提示，请帮小明计算，他每月乘坐地铁支出的总费用 提示信息: 北京公交地铁新票价确定 据北京市发改委网站消息称，北京市将从2015年12月28起实施公共交通新票价：地铁6公里(含)内3元，公交车10公里(含)内2元，使用市政交通一卡通刷卡乘公交车普通卡5折，学生卡2.5折。 　　具体实施方案如下： 　　一、城市公共电汽车价格调整为：10公里(含)内2元，10公里以上部分，每增加1元可乘坐5公里。使用市政交通一卡通刷卡乘坐城市公共电汽车，市域内路段给予普通卡5折，学生卡2.5折优惠;市域外路段维持现行折扣优惠不变。享受公交政策的郊区客运价格，由各区、县政府按照城市公共电汽车价格制定。 　　二、轨道交通价格调整为：6公里(含)内3元;6公里至12公里(含)4元;12公里至22公里(含)5元;22公里至32公里(含)6元;32公里以上部分，每增加1元可乘坐20公里。使用市政交通一卡通刷卡乘坐轨道交通，每自然月内每张卡支出累计满100元以后的乘次，价格给予8折优惠;满150元以后的乘次，价格给予5折优惠;支出累计达到400元以后的乘次，不再享受打折优惠。 要求： 假设每个月，小明都需要上20天班，每次上班需要来回1次，即每天需要乘坐2次同样路线的地铁；每月月初小明第一次刷公交卡时，扣款5元；编写程序，帮小明完成每月乘坐地铁需要的总费用 "},"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/zi-fu-chuan.html":{"url":"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/zi-fu-chuan.html","title":"字符串","keywords":"","body":"字符串输出 字符串输入 下标和切片 下标索引 切片 想一想 字符串常见操作 字符串输出 demo name = 'xiaoming' position = '讲师' address = '北京市昌平区建材城西路金燕龙办公楼1层' print('--------------------------------------------------') print(\"姓名：%s\"%name) print(\"职位：%s\"%position) print(\"公司地址：%s\"%address) print('--------------------------------------------------') 结果: -------------------------------------------------- 姓名： xiaoming 职位： 讲师 公司地址： 北京市昌平区建材城西路金燕龙办公楼1层 -------------------------------------------------- 字符串输入 之前在学习input的时候，通过它能够完成从键盘获取数据，然后保存到指定的变量中； 注意：input获取的数据，都以字符串的方式进行保存，即使输入的是数字，那么也是以字符串方式保存 demo: userName = input('请输入用户名:') print(\"用户名为：%s\"%userName) password = input('请输入密码:') print(\"密码为：%s\"%password) 结果：（根据输入的不同结果也不同） 请输入用户名:dongGe 用户名为： dongGe 请输入密码:haohaoxuexitiantianxiangshang 密码为： haohaoxuexitiantianxiangshang 下标和切片 下标索引 所谓“下标”，就是编号，就好比超市中的存储柜的编号，通过这个编号就能找到相应的存储空间 列表与元组支持下标索引好理解，字符串实际上就是字符的数组，所以也支持下标索引。 如果有字符串:name = 'abcdef'，在内存中的实际存储如下: 如果想取出部分字符，那么可以通过下标的方法，（注意python中下标从 0 开始） >>> name = 'abcdef' >>> name[0] a >>> name[1] b >>> name[2] c 切片 切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。 切片的语法：[起始:结束:步长] 注意：选取的区间属于左闭右开型，即从\"起始\"位开始，到\"结束\"位的前一位结束（不包含结束位本身)。 我们以字符串为例讲解。 如果取出一部分，则可以在中括号[]中，使用 >>> a = \"abcdef\" >>> a[:3] 'abc' >>> a[::2] 'ace' >>> a[5:1:2] '' >>> a[1:5:2] 'bd' >>> a[::-2] 'fdb' >>> a[5:1:-2] 'fd' 想一想 给定一个字符串aStr, 请反转字符串 字符串常见操作 str = \"My Name is Dinson\" # print(str.index(\"n\")) # 13 索引字符 无该字符则报错 # print(str.rindex(\"n\")) # 16 从右边开始索引字符 无该字符则报错 # print(str.find(\"y\")) # 1 索引字符 无该字符则返回-1 # print(str.rfind(\"n\")) # 16 从右边开始索引字符 无该字符则返回-1 # print(str.count(\"n\")) # 2 字符出现的个数 # print(\"dinson\".capitalize()) # Dinson 首字母大写 # print(str.center(24, \"-\")) # ---My Name is Dinson---- # print(str.ljust(24, \"-\")) # My Name is Dinson------- # print(str.rjust(24, \"-\")) # -------My Name is Dinson # print(str.zfill(24)) # 0000000My Name is Dinson # print(str.endswith(\"on\")) # True 判断是否以该字符结束 # print(str.startswith(\"my\")) # False 判断是否以该字符开始 # print(\"a\\ta\".expandtabs(10)) # a a # print(\"_\".join([\"a\", \"b\", \"c\", \"d\"])) # a_b_c_d # print(str.swapcase()) # mY nAME IS dINSON 大小写互换 # print(str.lower()) # my name is dinson # print(str.upper()) # MY NAME IS DINSON # print(str.replace(\"Dinson\", \"Mike\")) # My Name is Mike # print(\"\\n Dinson \\n\".strip()) # Dinson 去除左右空格和换行 # print(\"\\n Dinson \\n\".lstrip()) # Dinson \\n 去除左边空格和换行 # print(\"\\n Dinson \\n\".rstrip()) # \\n Dinson 去除右边空格和换行 # print(\"aaaaa\".split(\"a\", 2)) # ['', '', 'aaa'] 从左切割 # print(\"aaaaa\".rsplit(\"a\", 2)) # ['aaa', '', ''] 从右切割 # print(\"Dinson\".partition(\"n\")) # ('Di', 'n', 'son') 切割成固定三个元组 # print(\"Dinson\".rpartition(\"n\")) # ('Dinso', 'n', '')从右边切割成固定三个元组 # print(\"a\\nb\".splitlines()) # ['a', 'b'] 根据不用系统换行符分割 # print(\"my name is dinson\".title()) # My Name Is Dinson # p1 = str.maketrans(\"abcdefghijklmnopqrstuvwxyz MND\", \"9352401867peiwqcmzoshlmabv$*&^\") # p2 = str.maketrans(\"9352401867peiwqcmzoshlmabv$*&^\", \"abcdefghijklmnopqrstuvwxyz MND\") # print(str.translate(p1)) # *b$&9i4$6o$^6woqw # print(str.translate(p1).translate(p2)) # My Name is Dinson # print(\"name:{name},age:{age}\".format(name=\"Dinson\", age=18)) # name:Dinson,age:18 # print(\"name:{name},age:{age}\".format_map({\"name\": \"Dinson\", \"age\": 18})) # name:Dinson,age:18 # print(\"123\".isdecimal()) # True 是否为阿拉伯数字(非负整数) # print(\"123\".isalnum()) # True 是否为阿拉伯数字(非负整数) # print(\"123\".isnumeric()) # True 是否为阿拉伯数字(非负整数) # print(\"123\".isdigit()) # True 是否为阿拉伯数字(非负整数) # print(\"abcdABCD\".isalpha()) # True 是否为字母 # print(\"_1a中国\".isidentifier()) # True 是否为合法标识符 # print(\"abcd\".islower()) # True 是否全部为小写 # print(\"ABCD\".isupper()) # True 是否全部为大写 # print(\"My Name Is Dinson\".istitle()) # True 是否为标题格式 # print(\"\\t\".isspace()) # True 是否全部为空格 # print(str.isprintable()) # True tty file,drive file不可打印 "},"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/lie-biao.html":{"url":"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/lie-biao.html","title":"列表","keywords":"","body":"列表介绍 列表的格式 打印列表 列表的循环遍历 使用for循环 使用while循环 列表所有操作 列表的相关操作 添加元素(\"增\"append, extend, insert) 修改元素(\"改\") 查找元素(\"查\"in, not in, index, count) 删除元素(\"删\"del, pop, remove) 排序(sort, reverse) 列表的嵌套 列表嵌套 应用 列表介绍 想一想： 前面学习的字符串可以用来存储一串信息，那么想一想，怎样存储咱们班所有同学的名字呢？ 定义100个变量，每个变量存放一个学生的姓名可行吗？有更好的办法吗？ 答： 列表 列表的格式 变量A的类型为列表 namesList = ['xiaoWang','xiaoZhang','xiaoHua'] 比C语言的数组强大的地方在于列表中的元素可以是不同类型的 testList = [1, 'a'] 打印列表 demo: namesList = ['xiaoWang','xiaoZhang','xiaoHua'] print(namesList[0]) print(namesList[1]) print(namesList[2]) 结果： xiaoWang xiaoZhang xiaoHua 列表的循环遍历 使用for循环 为了更有效率的输出列表的每个数据，可以使用循环来完成 demo: namesList = ['xiaoWang','xiaoZhang','xiaoHua'] for name in namesList: print(name) 结果: xiaoWang xiaoZhang xiaoHua 使用while循环 为了更有效率的输出列表的每个数据，可以使用循环来完成 demo: namesList = ['xiaoWang','xiaoZhang','xiaoHua'] length = len(namesList) i = 0 while i 结果: xiaoWang xiaoZhang xiaoHua 列表所有操作 name = [\"张三\", \"李四\", \"王五\", \"赵六\", \"赵六\"] print(name.clear()) # [] print(name.count(\"赵六\")) # 2 print(name.index(\"赵六\")) # 3 print(name[0], name[2], name[-4]) # 张三 王五 李四 print(name[:]) # ['张三', '李四', '王五', '赵六', '赵六'] print(name[0:2]) # ['张三', '李四'] name.remove(\"李四\") print(name) # ['张三', '王五', '赵六', '赵六'] del name[2] print(name) # ['张三', '李四', '赵六', '赵六'] name[4] = \"孙七\" print(name) # ['张三', '李四', '王五', '赵六', '孙七'] name.insert(2, \"周八\") print(name) # ['张三', '李四', '周八', '王五', '赵六', '赵六'] name.append(\"孙七\") print(name) # ['张三', '李四', '王五', '赵六', '孙七'] name.pop() print(name) # ['张三', '李四', '王五', '赵六'] name.pop(1) # 李四 print(name) # ['张三', '王五', '赵六', '赵六'] name.remove(\"赵六\") print(name) # ['张三', '李四', '王五', '赵六'] name.reverse(); print(name) # ['赵六', '赵六', '王五', '李四', '张三'] name2 = [\"b\", \"d\", \"a\", \"e\", \"c\"] name2.sort(); print(name2) # ['a', 'b', 'c', 'd', 'e'] name2 = [\"b\", \"d\", \"a\", \"e\", \"c\"] name.extend(name2) print(name) # ['张三', '李四', '王五', '赵六', '赵六', 'b', 'd', 'a', 'e', 'c'] # 浅copy name1 = [\"a\", \"b\", [\"张三\", \"李四\"], \"d\", \"e\"] name2 = name.copy(); name1[1] = \"f\" name1[2][0] = \"王五\" print(name1) # ['a', 'f', ['王五', '李四'], 'd', 'e'] print(name2) # ['a', 'b', ['王五', '李四'], 'd', 'e'] # 深copy import copy name1 = [\"a\", \"b\", [\"张三\", \"李四\"], \"d\", \"e\"] name2 = copy.deepcopy(name1) name1[1] = \"f\" name1[2][0] = \"王五\" print(name1) # ['a', 'f', ['王五', '李四'], 'd', 'e'] print(name2) # ['a', 'b', ['张三', '李四'], 'd', 'e'] # 遍历 print(name[0:-1:2]) # ['张三', '王五', '赵六'] print(name[::2]) # ['张三', '王五', '赵六'] print(name[:]) # ['张三', '李四', '王五', '赵六', '赵六'] for i in name: print(i) # 张三李四王五赵六赵六 列表的相关操作 列表中存放的数据是可以进行修改的，比如\"增\"、\"删\"、\"改\"\" 添加元素(\"增\"append, extend, insert) append 通过append可以向列表添加元素 demo: #定义变量A，默认有3个元素 A = ['xiaoWang','xiaoZhang','xiaoHua'] print(\"-----添加之前，列表A的数据-----\") for tempName in A: print(tempName) #提示、并添加元素 temp = input('请输入要添加的学生姓名:') A.append(temp) print(\"-----添加之后，列表A的数据-----\") for tempName in A: print(tempName) 结果: -----添加之前，列表A的数据----- xiaoWang xiaoZhang xiaoHua 请输入要添加的学生姓名:dinson -----添加之后，列表A的数据----- xiaoWang xiaoZhang xiaoHua dinson extend 通过extend可以将另一个集合中的元素逐一添加到列表中 >>> a = [1, 2] >>> b = [3, 4] >>> a.append(b) >>> a [1, 2, [3, 4]] >>> a.extend(b) >>> a [1, 2, [3, 4], 3, 4] insert insert(index, object) 在指定位置index前插入元素object >>> a = [0, 1, 2] >>> a.insert(1, 3) >>> a [0, 3, 1, 2] 修改元素(\"改\") 修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改 demo: #定义变量A，默认有3个元素 A = ['xiaoWang','xiaoZhang','xiaoHua'] print(\"-----修改之前，列表A的数据-----\") for tempName in A: print(tempName) #修改元素 A[1] = 'xiaoLu' print(\"-----修改之后，列表A的数据-----\") for tempName in A: print(tempName) 结果: -----修改之前，列表A的数据----- xiaoWang xiaoZhang xiaoHua -----修改之后，列表A的数据----- xiaoWang xiaoLu xiaoHua 查找元素(\"查\"in, not in, index, count) 所谓的查找，就是看看指定的元素是否存在 in, not in python中查找的常用方法为： in（存在）,如果存在那么结果为true，否则为false not in（不存在），如果不存在那么结果为true，否则false demo #待查找的列表 nameList = ['xiaoWang','xiaoZhang','xiaoHua'] #获取用户要查找的名字 findName = input('请输入要查找的姓名:') #查找是否存在 if findName in nameList: print('在字典中找到了相同的名字') else: print('没有找到') 结果1：(找到) >>> 请输入要查找的姓名: xiaoWang 在字典中找到了相同的名字 结果2：(没有找到) >>> 请输入要查找的姓名: xiaoMing 没有找到 说明： in的方法只要会用了，那么not in也是同样的用法，只不过not in判断的是不存在 index, count index和count与字符串中的用法相同 >>> a = ['a', 'b', 'c', 'a', 'b'] >>> a.index('a', 1, 3) # 注意是左闭右开区间 Traceback (most recent call last): File \"\", line 1, in ValueError: 'a' is not in list >>> a.index('a', 1, 4) 3 >>> a.count('b') 2 >>> a.count('d') 0 删除元素(\"删\"del, pop, remove) 类比现实生活中，如果某位同学调班了，那么就应该把这个条走后的学生的姓名删除掉；在开发中经常会用到删除这种功能。 列表元素的常用删除方法有： del：根据下标进行删除 pop：删除最后一个元素 remove：根据元素的值进行删除 demo:(del) movieName = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情'] print('------删除之前------') for tempName in movieName: print(tempName) del movieName[2] print('------删除之后------') for tempName in movieName: print(tempName) 结果: ------删除之前------ 加勒比海盗 骇客帝国 第一滴血 指环王 霍比特人 速度与激情 ------删除之后------ 加勒比海盗 骇客帝国 指环王 霍比特人 速度与激情 demo:(pop) movieName = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情'] print('------删除之前------') for tempName in movieName: print(tempName) movieName.pop() print('------删除之后------') for tempName in movieName: print(tempName) 结果: ------删除之前------ 加勒比海盗 骇客帝国 第一滴血 指环王 霍比特人 速度与激情 ------删除之后------ 加勒比海盗 骇客帝国 第一滴血 指环王 霍比特人 demo:(remove) movieName = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情'] print('------删除之前------') for tempName in movieName: print(tempName) movieName.remove('指环王') print('------删除之后------') for tempName in movieName: print(tempName) 结果: ------删除之前------ 加勒比海盗 骇客帝国 第一滴血 指环王 霍比特人 速度与激情 ------删除之后------ 加勒比海盗 骇客帝国 第一滴血 霍比特人 速度与激情 排序(sort, reverse) sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。 reverse方法是将list逆置。 >>> a = [1, 4, 2, 3] >>> a [1, 4, 2, 3] >>> a.reverse() >>> a [3, 2, 4, 1] >>> a.sort() >>> a [1, 2, 3, 4] >>> a.sort(reverse=True) >>> a [4, 3, 2, 1]>>> a = [1, 4, 2, 3] >>> a [1, 4, 2, 3] >>> a.reverse() >>> a [3, 2, 4, 1] >>> a.sort() >>> a [1, 2, 3, 4] >>> a.sort(reverse=True) >>> a [4, 3, 2, 1] 列表的嵌套 列表嵌套 类似while循环的嵌套，列表也是支持嵌套的 一个列表中的元素又是一个列表，那么这就是列表的嵌套 schoolNames = [[ '北京大学' , '清华大学' ], [ '南开大学' , '天津大学' , '天津师范大学' ], [ '山东大学' , '中国海洋大学' ]] 应用 一个学校，有3个办公室，现在有8位老师等待工位的分配，请编写程序，完成随机的分配 import random # 定义一个列表用来保存3个办公室 offices = [[],[],[]] # 定义一个列表用来存储8位老师的名字 names = ['A','B','C','D','E','F','G','H'] i = 0 for name in names: index = random.randint(0,2) offices[index].append(name) i = 1 for tempNames in offices: print('办公室%d的人数为:%d'%(i,len(tempNames))) i+=1 for name in tempNames: print(\"%s\"%name,end='') print(\"\\n\") print(\"-\"*20) 运行结果如下: 办公室1的人数为:2 BC -------------------- 办公室2的人数为:3 AEH -------------------- 办公室3的人数为:3 DFG -------------------- "},"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/yuan-zu.html":{"url":"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/yuan-zu.html","title":"元组","keywords":"","body":"元组 元组 Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。 >>> aTuple = ('et',77,99.9) >>> aTuple ('et',77,99.9) 访问元组 修改元组 说明：python中不允许修改元组的数据，包括不能删除其中的元素。 元组的内置函数count, index index和count与字符串和列表中的用法相同 >>> a = ('a', 'b', 'c', 'a', 'b') >>> a.index('a', 1, 3) # 注意是左闭右开区间 Traceback (most recent call last): File \"\", line 1, in ValueError: tuple.index(x): x not in tuple >>> a.index('a', 1, 4) 3 >>> a.count('b') 2 >>> a.count('d') 0 "},"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/zi-dian.html":{"url":"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/zi-dian.html","title":"字典","keywords":"","body":"字典介绍 生活中的字典 软件开发中的字典 根据键访问值 字典介绍 想一想： 如果有列表 nameList = ['xiaoZhang', 'xiaoWang', 'xiaoLi']; 需要对\"xiaoWang\"这个名字写错了，通过代码修改： nameList[1] = 'xiaoxiaoWang' 如果列表的顺序发生了变化，如下 nameList = ['xiaoWang', 'xiaoZhang', 'xiaoLi']; 此时就需要修改下标，才能完成名字的修改 nameList[0] = 'xiaoxiaoWang' 有没有方法，既能存储多个数据，还能在访问元素的很方便就能够定位到需要的那个元素呢？ 答： 字典 另一个场景： 学生信息列表，每个学生信息包括学号、姓名、年龄等，如何从中找到某个学生的信息？ >>> studens = [[1001, \"王宝强\", 24], [1002, \"马蓉\", 23], [1005, \"宋喆\"，24], ...] 循环遍历？ No！ 生活中的字典 软件开发中的字典 变量info为字典类型： info = {'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'} 说明： 字典和列表一样，也能够存储多个数据 列表中找某个元素时，是根据下标进行的 字典中找某个元素时，是根据'名字'（就是冒号:前面的那个值，例如上面代码中的'name'、'id'、'sex'） 字典的每个元素由2部分组成，键:值。例如 'name':'班长' ,'name'为键，'班长'为值 根据键访问值 info = {'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'} print(info['name']) print(info['address']) 结果: 班长 地球亚洲中国北京 若访问不存在的键，则会报错： >>> info['age'] Traceback (most recent call last): File \"\", line 1, in KeyError: 'age' 在我们不确定字典中是否存在某个键而又想获取其值时，可以使用get方法，还可以设置默认值： >>> age = info.get('age') >>> age #'age'键不存在，所以age为None >>> type(age) >>> age = info.get('age', 18) # 若info中不存在'age'这个键，就返回默认值18 >>> age 18 "},"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/gong-gong-fang-fa.html":{"url":"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/gong-gong-fang-fa.html","title":"公共方法","keywords":"","body":"公共方法 运算符 python内置函数 多维列表/元祖访问的示例 公共方法 运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * 'Hi!' * 4 ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 复制 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 + >>> \"hello \" + \"itcast\" 'hello itcast' >>> [1, 2] + [3, 4] [1, 2, 3, 4] >>> ('a', 'b') + ('c', 'd') ('a', 'b', 'c', 'd') * >>> 'ab'*4 'ababab' >>> [1, 2]*4 [1, 2, 1, 2, 1, 2, 1, 2] >>> ('a', 'b')*4 ('a', 'b', 'a', 'b', 'a', 'b', 'a', 'b') in >>> 'itc' in 'hello itcast' True >>> 3 in [1, 2] False >>> 4 in (1, 2, 3, 4) True >>> \"name\" in {\"name\":\"Delron\", \"age\":24} True 注意，in在对字典操作时，判断的是字典的键 python内置函数 Python包含了以下内置函数 序号 方法 描述 1 cmp(item1, item2) 比较两个值 2 len(item) 计算容器中元素个数 3 max(item) 返回容器中元素最大值 4 min(item) 返回容器中元素最小值 5 del(item) 删除变量 cmp >>> cmp(\"hello\", \"itcast\") -1 >>> cmp(\"itcast\", \"hello\") 1 >>> cmp(\"itcast\", \"itcast\") 0 >>> cmp([1, 2], [3, 4]) -1 >>> cmp([1, 2], [1, 1]) 1 >>> cmp([1, 2], [1, 2, 3]) -1 >>> cmp({\"a\":1}, {\"b\":1}) -1 >>> cmp({\"a\":2}, {\"a\":1}) 1 >>> cmp({\"a\":2}, {\"a\":2, \"b\":1}) -1 注意：cmp在比较字典数据时，先比较键，再比较值。 len >>> len(\"hello itcast\") 12 >>> len([1, 2, 3, 4]) 4 >>> len((3,4)) 2 >>> len({\"a\":1, \"b\":2}) 2 注意：len在操作字典数据时，返回的是键值对个数。 max >>> max(\"hello itcast\") 't' >>> max([1,4,522,3,4]) 522 >>> max({\"a\":1, \"b\":2}) 'b' >>> max({\"a\":10, \"b\":2}) 'b' >>> max({\"c\":10, \"b\":2}) 'c' del del有两种用法，一种是del加空格，另一种是del() >>> tuple1 = [(2,3),(4,5)] >>> tuple1[0] (2, 3) >>> tuple1[0][0] 2 >>> tuple1[0][2] Traceback (most recent call last): File \"\", line 1, in IndexError: tuple index out of range >>> tuple1[0][1] 3 >>> tuple1[2][2] Traceback (most recent call last): File \"\", line 1, in IndexError: list index out of range >>> tuple2 = tuple1+[(3)] >>> tuple2 [(2, 3), (4, 5), 3] >>> tuple2[2] 3 >>> tuple2[2][0] Traceback (most recent call last): File \"\", line 1, in TypeError: 'int' object is not subscriptable 多维列表/元祖访问的示例 >>> tuple1 = [(2,3),(4,5)] >>> tuple1[0] (2, 3) >>> tuple1[0][0] 2 >>> tuple1[0][2] Traceback (most recent call last): File \"\", line 1, in IndexError: tuple index out of range >>> tuple1[0][1] 3 >>> tuple1[2][2] Traceback (most recent call last): File \"\", line 1, in IndexError: list index out of range >>> tuple2 = tuple1+[(3)] >>> tuple2 [(2, 3), (4, 5), 3] >>> tuple2[2] 3 >>> tuple2[2][0] Traceback (most recent call last): File \"\", line 1, in TypeError: 'int' object is not subscriptable "},"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/yin-yong.html":{"url":"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/yin-yong.html","title":"引用","keywords":"","body":"引用 想一想 引用 可变类型与不可变类型 引用 想一想 >>> a = 1 >>> b = a >>> b 1 >>> a = 2 >>> a 2 请问此时b的值为多少？ >>> a = [1, 2] >>> b = a >>> b [1, 2] >>> a.append(3) >>> a [1, 2, 3] 请问此时b的值又是多少？ 引用 在python中，值是靠引用来传递来的。 我们可以用id()来判断两个变量是否为同一个值的引用。我们可以将id值理解为那块内存的地址标示。 >>> a = 1 >>> b = a >>> id(a) 13033816 >>> id(b) # 注意两个变量的id值相同 13033816 >>> a = 2 >>> id(a) # 注意a的id值已经变了 13033792 >>> id(b) # b的id值依旧 13033816 36.png 可变类型与不可变类型 可变类型，值可以改变： 列表 list 字典 dict 不可变类型，值不可以改变： 数值类型 int, long, bool, float 字符串 str 元组 tuple 怎样交换两个变量的值？ "},"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/zuo-ye.html":{"url":"primary/zi-fu-chuan-3001-lie-biao-3001-yuan-zu-3001-zi-dian/zuo-ye.html","title":"作业","keywords":"","body":"编程实现对一个元素全为数字的列表，求最大值、最小值 编写程序，完成以下要求： 统计字符串中，各个字符的个数 比如：\"hello world\" 字符串统计的结果为： h:1 e:1 l:3 o:2 d:1 r:1 w:1 编写程序，完成以下要求： 完成一个路径的组装 先提示用户多次输入路径，最后显示一个完成的路径，比如 /home/python/ftp/share 编写程序，完成“名片管理器”项目 需要完成的基本功能： 添加名片 删除名片 修改名片 查询名片 退出系统 程序运行后，除非选择退出系统，否则重复执行功能 "},"primary/han-shu/yin-zi.html":{"url":"primary/han-shu/yin-zi.html","title":"引子","keywords":"","body":"函数 什么是函数 函数 什么是函数 请看如下代码: print(\" _ooOoo_ \") print(\" o8888888o \") print(\" 88 . 88 \") print(\" (| -_- |) \") print(\" O\\\\ = /O \") print(\" ____/`---'\\\\____ \") print(\" . ' \\\\| |// `. \") print(\" / \\\\||| : |||// \\\\ \") print(\" / _||||| -:- |||||- \\\\ \") print(\" | | \\\\\\\\\\\\ - /// | | \") print(\" | \\\\_| ''\\\\---/'' | | \") print(\" \\\\ .-\\\\__ `-` ___/-. / \") print(\" ___`. .' /--.--\\\\ `. . __ \") print(\" .\"\" '_/___.' >'\"\". \") print(\" | | : `- \\\\`.;`\\\\ _ /`;.`/ - ` : | | \") print(\" \\\\ \\\\ `-. \\\\_ __\\\\ /__ _/ .-` / / \") print(\" ======`-.____`-.___\\\\_____/___.-`____.-'====== \") print(\" `=---=' \") print(\" \") print(\" ............................................. \") print(\" 佛祖镇楼 BUG辟易 \") print(\" 佛曰: \") print(\" 写字楼里写字间，写字间里程序员； \") print(\" 程序人员写程序，又拿程序换酒钱。 \") print(\" 酒醒只在网上坐，酒醉还来网下眠； \") print(\" 酒醉酒醒日复日，网上网下年复年。 \") print(\" 但愿老死电脑间，不愿鞠躬老板前； \") print(\" 奔驰宝马贵者趣，公交自行程序员。 \") print(\" 别人笑我忒疯癫，我笑自己命太贱； \") print(\" 不见满街漂亮妹，哪个归得程序员？\") 运行后的现象: _ooOoo_ o8888888o 88 . 88 (| -_- |) O\\ = /O ____/`---'\\____ . ' \\| |// `. / \\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ . '_/___.' >'. | | : `- \\`.;`\\ _ /`;.`/ - ` : | | \\ \\ `-. \\_ __\\ /__ _/ .-` / / ======`-.____`-.___\\_____/___.-`____.-'====== `=---=' ............................................. 佛祖镇楼 BUG辟易 佛曰: 写字楼里写字间，写字间里程序员； 程序人员写程序，又拿程序换酒钱。 酒醒只在网上坐，酒醉还来网下眠； 酒醉酒醒日复日，网上网下年复年。 但愿老死电脑间，不愿鞠躬老板前； 奔驰宝马贵者趣，公交自行程序员。 别人笑我忒疯癫，我笑自己命太贱； 不见满街漂亮妹，哪个归得程序员？ 想一想： 如果一个程序在不同的地方需要输出“佛祖镇楼”，程序应该怎样设计？ if 条件1: 输出‘佛祖镇楼’ ...(省略)... if 条件2: 输出‘佛祖镇楼’ ...(省略)... 如果需要输出多次，是否意味着要编写这块代码多次呢？ 小总结: 如果在开发程序时，需要某块代码多次，但是为了提高编写的效率以及代码的重用，所以把具有独立功能的代码块组织为一个小模块，这就是函数 "},"primary/han-shu/han-shu-shi-yong.html":{"url":"primary/han-shu/han-shu-shi-yong.html","title":"函数使用","keywords":"","body":"函数定义和调用 定义函数 调用函数 练一练 函数的文档说明 函数参数(一) 定义带有参数的函数 调用带有参数的函数 练一练 调用函数时参数的顺序 小总结 函数参数(二) 1. 缺省参数 2.不定长参数 3. 引用传参 函数返回值 “返回值”介绍 带有返回值的函数 保存函数的返回值 在python中我们可不可以返回多个值？ 4种函数的类型 无参数，无返回值的函数 无参数，有返回值的函数 有参数，无返回值的函数 有参数，有返回值的函数 小总结 函数的嵌套调用 函数应用：打印图形和数学计算 目标 思考&实现1 参考代码1 思考&实现2 参考代码2 局部变量 什么是局部变量 小总结 全局变量 什么是全局变量 全局变量和局部变量名字相同问题 修改全局变量 总结1: 可变类型的全局变量 总结2： 递归函数 什么是递归函数 递归函数的作用 匿名函数 应用场合 函数使用注意事项 函数定义和调用 定义函数 定义函数的格式如下： def 函数名(): 代码 demo: # 定义一个函数，能够完成打印信息的功能 def printInfo(): print '------------------------------------' print ' 人生苦短，我用Python' print '------------------------------------' 调用函数 定义了函数之后，就相当于有了一个具有某些功能的代码，想要让这些代码能够执行，需要调用它 调用函数很简单的，通过函数名()即可完成调用 demo: # 定义完函数后，函数是不会自动执行的，需要调用它才可以 printInfo() 练一练 要求：定义一个函数，能够输出自己的姓名和年龄，并且调用这个函数让它执行 使用def定义函数 编写完函数之后，通过函数名()进行调用 函数的文档说明 >>> def test(a,b): ... \"用来完成对2个数求和\" ... print(\"%d\"%(a+b)) ... >>> >>> test(11,22) 33 如果执行，以下代码 >>> help(test) 能够看到test函数的相关说明 Help on function test in module __main__: test(a, b) 用来完成对2个数求和 (END) 函数参数(一) 思考一个问题，如下： 现在需要定义一个函数，这个函数能够完成2个数的加法运算，并且把结果打印出来，该怎样设计？下面的代码可以吗？有什么缺陷吗？ def add2num(): a = 11 b = 22 c = a+b print c 为了让一个函数更通用，即想让它计算哪两个数的和，就让它计算哪两个数的和，在定义函数的时候可以让函数接收数据，就解决了这个问题，这就是 函数的参数 定义带有参数的函数 示例如下： def add2num(a, b): c = a+b print c 调用带有参数的函数 以调用上面的add2num(a, b)函数为例: def add2num(a, b): c = a+b print c add2num(11, 22) #调用带有参数的函数时，需要在小括号中，传递数据 调用带有参数函数的运行过程： 练一练 要求：定义一个函数，完成前2个数完成加法运算，然后对第3个数，进行减法；然后调用这个函数 使用def定义函数，要注意有3个参数 调用的时候，这个函数定义时有几个参数，那么就需要传递几个参数 调用函数时参数的顺序 >>> def test(a,b): ... print(a,b) ... >>> test(1,2) 1 2 >>> test(b=1,a=2) 2 1 >>> >>> test(b=1,2) File \"\", line 1 SyntaxError: positional argument follows keyword argument >>> >>> 小总结 定义时小括号中的参数，用来接收参数用的，称为 “形参” 调用时小括号中的参数，用来传递给函数用的，称为 “实参” 函数参数(二) 1. 缺省参数 调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入： def printinfo( name, age = 35 ): # 打印任何传入的字符串 print \"Name: \", name print \"Age \", age # 调用printinfo函数 printinfo(name=\"miki\" ) printinfo( age=9,name=\"miki\" ) 以上实例输出结果： Name: miki Age 35 Name: miki Age 9 注意：带有默认值的参数一定要位于参数列表的最后面。 >>> def printinfo(name, age=35, sex): ... print name ... File \"\", line 1 SyntaxError: non-default argument follows default argument 2.不定长参数 有时可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，声明时不会命名。 基本语法如下： def functionname([formal_args,] *args, **kwargs): \"函数_文档字符串\" function_suite return [expression] 加了星号（*）的变量args会存放所有未命名的变量参数，args为元组；而加**的变量kwargs会存放命名参数，即形如key=value的参数， kwargs为字典。 >>> def fun(a, b, *args, **kwargs): ... \"\"\"可变参数演示示例\"\"\" ... print \"a =\", a ... print \"b =\", b ... print \"args =\", args ... print \"kwargs: \" ... for key, value in kwargs.items(): ... print key, \"=\", value ... >>> fun(1, 2, 3, 4, 5, m=6, n=7, p=8) # 注意传递的参数对应 a = 1 b = 2 args = (3, 4, 5) kwargs: p = 8 m = 6 n = 7 >>> >>> >>> >>> c = (3, 4, 5) >>> d = {\"m\":6, \"n\":7, \"p\":8} >>> fun(1, 2, *c, **d) # 注意元组与字典的传参方式 a = 1 b = 2 args = (3, 4, 5) kwargs: p = 8 m = 6 n = 7 >>> >>> >>> >>> fun(1, 2, c, d) # 注意不加星号与上面的区别 a = 1 b = 2 args = ((3, 4, 5), {'p': 8, 'm': 6, 'n': 7}) kwargs: >>> >>> 3. 引用传参 可变类型与不可变类型的变量分别作为函数参数时，会有什么不同吗？ Python有没有类似C语言中的指针传参呢？ >>> def selfAdd(a): ... \"\"\"自增\"\"\" ... a += a ... >>> a_int = 1 >>> a_int 1 >>> selfAdd(a_int) >>> a_int 1 >>> a_list = [1, 2] >>> a_list [1, 2] >>> selfAdd(a_list) >>> a_list [1, 2, 1, 2] Python中函数参数是引用传递（注意不是值传递）。对于不可变类型，因变量不能修改，所以运算不会影响到变量自身；而对于可变类型来说，函数体中的运算有可能会更改传入的参数变量。 想一想为什么 >>> def selfAdd(a): ... \"\"\"自增\"\"\" ... a = a + a # 我们更改了函数体的这句话 ... >>> a_int = 1 >>> a_int 1 >>> selfAdd(a_int) >>> a_int 1 >>> a_list = [1, 2] >>> a_list [1, 2] >>> selfAdd(a_list) >>> a_list [1, 2] # 想一想为什么没有变呢？ 函数返回值 “返回值”介绍 现实生活中的场景: 我给儿子10块钱，让他给我买包烟。这个例子中，10块钱是我给儿子的，就相当于调用函数时传递到参数，让儿子买烟这个事情最终的目标是，让他把烟给你带回来然后给你对么，，，此时烟就是返回值 开发中的场景： 定义了一个函数，完成了获取室内温度，想一想是不是应该把这个结果给调用者，只有调用者拥有了这个返回值，才能够根据当前的温度做适当的调整 综上所述： 所谓“返回值”，就是程序中函数完成一件事情后，最后给调用者的结果 带有返回值的函数 想要在函数中把结果返回给调用者，需要在函数中使用return 如下示例: def add2num(a, b): c = a+b return c 或者 def add2num(a, b): return a+b 保存函数的返回值 在本小节刚开始的时候，说过的“买烟”的例子中，最后儿子给你烟时，你一定是从儿子手中接过来 对么，程序也是如此，如果一个函数返回了一个数据，那么想要用这个数据，那么就需要保存 保存函数的返回值示例如下: #定义函数 def add2num(a, b): return a+b #调用函数，顺便保存函数的返回值 result = add2num(100,98) #因为result已经保存了add2num的返回值，所以接下来就可以使用了 print result 结果: 198 在python中我们可不可以返回多个值？ >>> def divid(a, b): ... shang = a//b ... yushu = a%b ... return shang, yushu ... >>> sh, yu = divid(5, 2) >>> sh 5 >>> yu 1 本质是利用了元组 4种函数的类型 函数根据有没有参数，有没有返回值，可以相互组合，一共有4种 无参数，无返回值 无参数，又反悔 有参数，无返回值 有参数，有返回值 无参数，无返回值的函数 此类函数，不能接收参数，也没有返回值，一般情况下，打印提示灯类似的功能，使用这类的函数 def printMenu(): print('--------------------------') print(' xx涮涮锅 点菜系统') print('') print(' 1. 羊肉涮涮锅') print(' 2. 牛肉涮涮锅') print(' 3. 猪肉涮涮锅') print('--------------------------') 结果: -------------------------- xx涮涮锅 点菜系统 1. 羊肉涮涮锅 2. 牛肉涮涮锅 3. 猪肉涮涮锅 -------------------------- 无参数，有返回值的函数 此类函数，不能接收参数，但是可以返回某个数据，一般情况下，像采集数据，用此类函数 # 获取温度 def getTemperature(): #这里是获取温度的一些处理过程 #为了简单起见，先模拟返回一个数据 return 24 temperature = getTemperature() print('当前的温度为:%d'%temperature) 结果: 当前的温度为: 24 有参数，无返回值的函数 此类函数，能接收参数，但不可以返回数据，一般情况下，对某些变量设置数据而不需结果时，用此类函数 有参数，有返回值的函数 此类函数，不仅能接收参数，还可以返回某个数据，一般情况下，像数据处理并需要结果的应用，用此类函数 # 计算1~num的累积和 def calculateNum(num): result = 0 i = 1 while i 结果: 1~100的累积和为: 5050 小总结 函数根据有没有参数，有没有返回值可以相互组合 定义函数时，是根据实际的功能需求来设计的，所以不同开发人员编写的函数类型各不相同 函数的嵌套调用 def testB(): print('---- testB start----') print('这里是testB函数执行的代码...(省略)...') print('---- testB end----') def testA(): print('---- testA start----') testB() print('---- testA end----') testA() 结果： ---- testA start---- ---- testB start---- 这里是testB函数执行的代码...(省略)... ---- testB end---- ---- testA end---- 小总结： 一个函数里面又调用了另外一个函数，这就是所谓的函数嵌套调用 如果函数A中，调用了另外一个函数B，那么先把函数B中的任务都执行完毕之后才会回到上次 函数A执行的位置 函数应用：打印图形和数学计算 目标 感受函数的嵌套调用 感受程序设计的思路,复杂问题分解为简单问题 思考&实现1 写一个函数打印一条横线 打印自定义行数的横线 参考代码1 # 打印一条横线 def printOneLine(): print(\"-\"*30) # 打印多条横线 def printNumLine(num): i=0 # 因为printOneLine函数已经完成了打印横线的功能， # 只需要多次调用此函数即可 while i 思考&实现2 写一个函数求三个数的和 写一个函数求三个数的平均值 参考代码2 # 求3个数的和 def sum3Number(a,b,c): return a+b+c # return 的后面可以是数值，也可是一个表达式 # 完成对3个数求平均值 def average3Number(a,b,c): # 因为sum3Number函数已经完成了3个数的就和，所以只需调用即可 # 即把接收到的3个数，当做实参传递即可 sumResult = sum3Number(a,b,c) aveResult = sumResult/3.0 return aveResult # 调用函数，完成对3个数求平均值 result = average3Number(11,2,55) print(\"average is %d\"%result) 局部变量 什么是局部变量 如下图所示: 小总结 局部变量，就是在函数内部定义的变量 不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响 局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储，这就是它的作用 全局变量 什么是全局变量 如果一个变量，既能在一个函数中使用，也能在其他的函数中使用，这样的变量就是全局变量 demo如下: # 定义全局变量 a = 100 def test1(): print(a) def test2(): print(a) # 调用函数 test1() test2() 运行结果: 全局变量和局部变量名字相同问题 看如下代码: 修改全局变量 既然全局变量，就是能够在所以的函数中进行使用，那么可否进行修改呢？ 代码如下: 总结1: 在函数外边定义的变量叫做全局变量 全局变量能够在所有的函数中进行访问 如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错 如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的，小技巧强龙不压地头蛇 可变类型的全局变量 >>> a = 1 >>> def f(): ... a += 1 ... print a ... >>> f() Traceback (most recent call last): File \"\", line 1, in File \"\", line 2, in f UnboundLocalError: local variable 'a' referenced before assignment >>> >>> >>> li = [1,] >>> def f2(): ... li.append(1) ... print li ... >>> f2() [1, 1] >>> li [1, 1] 总结2： 在函数中不使用global声明全局变量时不能修改全局变量的本质是不能修改全局变量的指向，即不能将全局变量指向新的数据。 对于不可变类型的全局变量来说，因其指向的数据不能修改，所以不使用global时无法修改全局变量。 对于可变类型的全局变量来说，因其指向的数据可以修改，所以不使用global时也可修改全局变量。 递归函数 什么是递归函数 通过前面的学习知道一个函数可以调用其他函数。 如果一个函数在内部不调用其它的函数，而是自己本身的话，这个函数就是递归函数。 递归函数的作用 举个例子，我们来计算阶乘n! = 1 * 2 * 3 * ... * n 解决办法1: 看阶乘的规律 1! = 1 2! = 2 × 1 = 2 × 1! 3! = 3 × 2 × 1 = 3 × 2! 4! = 4 × 3 × 2 × 1 = 4 × 3! ... n! = n × (n-1)! 解决办法2: 原理 匿名函数 用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。 lambda函数的语法只包含一个语句，如下： lambda [arg1 [,arg2,.....argn]]:expression 如下实例： sum = lambda arg1, arg2: arg1 + arg2 #调用sum函数 print \"Value of total : \", sum( 10, 20 ) print \"Value of total : \", sum( 20, 20 ) 以上实例输出结果： Value of total : 30 Value of total : 40 Lambda函数能接收任何数量的参数但只能返回一个表达式的值 匿名函数不能直接调用print，因为lambda需要一个表达式 应用场合 函数作为参数传递 自己定义函数>>> def fun(a, b, opt): ... print \"a =\", a ... print \"b =\", b ... print \"result =\", opt(a, b) ... >>> fun(1, 2, lambda x,y:x+y) a = 1 b = 2 result = 3 作为内置函数的参数 想一想，下面的数据如何指定按age或name排序？ stus = [ {\"name\":\"zhangsan\", \"age\":18}, {\"name\":\"lisi\", \"age\":19}, {\"name\":\"wangwu\", \"age\":17} ] 按name排序： >>> stus.sort(key = lambda x:x['name']) >>> stus [{'age': 19, 'name': 'lisi'}, {'age': 17, 'name': 'wangwu'}, {'age': 18, 'name': 'zhangsan'}] 按age排序： >>> stus.sort(key = lambda x:x['age']) >>> stus [{'age': 17, 'name': 'wangwu'}, {'age': 18, 'name': 'zhangsan'}, {'age': 19, 'name': 'lisi'}] 函数使用注意事项 自定义函数 无参数、无返回值 def 函数名(): 语句 无参数、有返回值 def 函数名(): 语句 return 需要返回的数值 注意: 一个函数到底有没有返回值，就看有没有return，因为只有return才可以返回数据 在开发中往往根据需求来设计函数需不需要返回值 函数中，可以有多个return语句，但是只要执行到一个return语句，那么就意味着这个函数的调用完成 有参数、无返回值 def 函数名(形参列表): 语句 注意： 在调用函数时，如果需要把一些数据一起传递过去，被调用函数就需要用参数来接收 参数列表中变量的个数根据实际传递的数据的多少来确定 有参数、有返回值 def 函数名(形参列表): 语句 return 需要返回的数值 函数名不能重复 调用函数 调用的方式为： 函数名([实参列表]) 调用时，到底写不写 实参 如果调用的函数 在定义时有形参，那么在调用的时候就应该传递参数 调用时，实参的个数和先后顺序应该和定义函数中要求的一致 如果调用的函数有返回值，那么就可以用一个变量来进行保存这个值 作用域 在一个函数中定义的变量，只能在本函数中用(局部变量) 在函数外定义的变量，可以在所有的函数中使用(全局变量) "},"primary/han-shu/zuo-ye.html":{"url":"primary/han-shu/zuo-ye.html","title":"作业","keywords":"","body":"必做题 编程实现 9*9乘法表 提示：使用循环嵌套 用函数实现求100-200里面所有的素数 提示：素数的特征是除了1和其本身能被整除，其它数都不能被整除的数 请用函数实现一个判断用户输入的年份是否是闰年的程序 提示： 1.能被400整除的年份 2.能被4整除，但是不能被100整除的年份 以上2种方法满足一种即为闰年 选做题 用函数实现输入某年某月某日，判断这一天是这一年的第几天？闰年情况也考虑进去 20160818 是今年第x天 编写“学生管理系统”，要求如下： 必须使用自定义函数，完成对程序的模块化 学生信息至少包含：姓名、年龄、学号，除此以外可以适当添加 必须完成的功能：添加、删除、修改、查询、退出 "},"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/wen-jian-cao-zuo-jie-shao.html":{"url":"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/wen-jian-cao-zuo-jie-shao.html","title":"文件操作介绍","keywords":"","body":"文件操作介绍 什么是文件 文件的作用 文件操作介绍 什么是文件 示例如下： 文件的作用 大家应该听说过一句话：“好记性不如烂笔头”。 不仅人的大脑会遗忘事情，计算机也会如此，比如一个程序在运行过程中用了九牛二虎之力终于计算出了结果，试想一下如果不把这些数据存放起来，相比重启电脑之后，“哭都没地方哭了” 可见，在把数据存储起来有做么大的价值 使用文件的目的： 就是把一些存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力 "},"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/wen-jian-de-du-xie.html":{"url":"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/wen-jian-de-du-xie.html","title":"文件相关操作","keywords":"","body":"文件的打开与关闭 打开文件 关闭文件 文件的读写 写数据(write) 读数据(read) 读数据（readlines） 读数据（readline） 想一想： 文件的随机读写 获取当前读写的位置 定位到某个位置 文件的重命名、删除 文件重命名 删除文件 文件的打开与关闭 想一想： 如果想用word编写一份简历，应该有哪些流程呢？ 打开word软件，新建一个word文件 写入个人简历信息 保存文件 关闭word软件 同样，在操作文件的整体过程与使用word编写一份简历的过程是很相似的 打开文件，或者新建立一个文件 读/写数据 关闭文件 打开文件 在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件 open(文件名，访问模式) 示例如下： f = open('test.txt', 'w') 说明: 访问模式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 关闭文件 close( ) 示例如下： # 新建一个文件，文件名为:test.txt f = open('test.txt', 'w') # 关闭这个文件 f.close() 文件的读写 写数据(write) 使用write()可以完成向文件写入数据 demo: f = open('test.txt', 'w') f.write('hello world, i am here!') f.close() 运行现象: 注意： 如果文件不存在那么创建，如果存在那么就先清空，然后写入数据 读数据(read) 使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据 demo: f = open('test.txt', 'r') content = f.read(5) print(content) print(\"-\"*30) content = f.read() print(content) f.close() 运行现象： hello ------------------------------ world, i am here! 注意： 如果open是打开一个文件，那么可以不用谢打开的模式，即只写open('test.txt') 如果使用读了多次，那么后面读取的数据是从上次读完后的位置开始的 读数据（readlines） 就像read没有参数时一样，readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素 f = open('test.txt', 'r') content = f.readlines() print(type(content)) i=1 for temp in content: print(\"%d:%s\"%(i, temp)) i+=1 f.close() 运行现象： 读数据（readline） f = open('test.txt', 'r') content = f.readline() print(\"1:%s\"%content) content = f.readline() print(\"2:%s\"%content) f.close() 想一想： 如果一个文件很大，比如5G，试想应该怎样把文件的数据读取到内存然后进行处理呢？ 文件的随机读写 获取当前读写的位置 在读写文件的过程中，如果想知道当前的位置，可以使用tell()来获取 # 打开一个已经存在的文件 f = open(\"test.txt\", \"r\") str = f.read(3) print \"读取的数据是 : \", str # 查找当前位置 position = f.tell() print \"当前文件位置 : \", position str = f.read(3) print \"读取的数据是 : \", str # 查找当前位置 position = f.tell() print \"当前文件位置 : \", position f.close() 定位到某个位置 如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek() seek(offset, from)有2个参数 offset:偏移量 from:方向 0:表示文件开头 1:表示当前位置 2:表示文件末尾 demo:把位置设置为：从文件开头，偏移5个字节 # 打开一个已经存在的文件 f = open(\"test.txt\", \"r\") str = f.read(30) print \"读取的数据是 : \", str # 查找当前位置 position = f.tell() print \"当前文件位置 : \", position # 重新设置位置 f.seek(5,0) # 查找当前位置 position = f.tell() print \"当前文件位置 : \", position f.close() demo:把位置设置为：离文件末尾，3字节处 # 打开一个已经存在的文件 f = open(\"test.txt\", \"r\") # 查找当前位置 position = f.tell() print \"当前文件位置 : \", position # 重新设置位置 f.seek(-3,2) # 读取到的数据为：文件最后3个字节数据 str = f.read() print \"读取的数据是 : \", str f.close() 文件的重命名、删除 有些时候，需要对文件进行重命名、删除等一些操作，python的os模块中都有这么功能 文件重命名 os模块中的rename()可以完成对文件的重命名操作 rename(需要修改的文件名, 新的文件名) import os os.rename(\"毕业论文.txt\", \"毕业论文-最终版.txt\") 删除文件 os模块中的remove()可以完成对文件的删除操作 remove(待删除的文件名) import os os.remove(\"毕业论文.txt\") "},"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/ying-yong-1-zhi-zuo-wen-jian-de-bei-fen.html":{"url":"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/ying-yong-1-zhi-zuo-wen-jian-de-bei-fen.html","title":"应用1：制作文件的备份","keywords":"","body":"应用1:制作文件的备份 任务描述 参考代码 应用1:制作文件的备份 任务描述 输入文件的名字，然后程序自动完成对文件进行备份 参考代码 oldFileName = input(\"请输入要拷贝的文件名字:\") oldFile = open(oldFileName,'r') # 如果打开文件 if oldFile: # 提取文件的后缀 fileFlagNum = oldFileName.rfind('.') if fileFlagNum > 0: fileFlag = oldFileName[fileFlagNum:] # 组织新的文件名字 newFileName = oldFileName[:fileFlagNum] + '[复件]' + fileFlag # 创建新文件 newFile = open(newFileName, 'w') # 把旧文件中的数据，一行一行的进行复制到新文件中 for lineContent in oldFile.readlines(): newFile.write(lineContent) # 关闭文件 oldFile.close() newFile.close() "},"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/wen-jian-de-da-kai-yu-guan-bi.html":{"url":"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/wen-jian-de-da-kai-yu-guan-bi.html","title":"文件夹相关操作","keywords":"","body":"文件夹的相关操作 创建文件夹 获取当前目录 改变默认目录 获取目录列表 删除文件夹 文件夹的相关操作 实际开发中，有时需要用程序的方式对文件夹进行一定的操作，比如创建、删除等 就像对文件操作需要os模块一样，如果要操作文件夹，同样需要os模块 创建文件夹 import os os.mkdir(\"张三\") 获取当前目录 import os os.getcwd() 改变默认目录 import os os.chdir(\"../\") 获取目录列表 import os os.listdir(\"./\") 删除文件夹 import os os.rmdir(\"张三\") "},"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/ying-yong-2-ff1a-pi-liang-xiu-gai-wen-jian-ming.html":{"url":"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/ying-yong-2-ff1a-pi-liang-xiu-gai-wen-jian-ming.html","title":"应用2：批量修改文件名","keywords":"","body":"应用：批量修改文件名 运行过程演示 参考代码 应用：批量修改文件名 运行过程演示 运行程序之前 运行程序之后 参考代码 # 批量在文件名前加前缀 import os funFlag = 1 # 1表示添加标志 2表示删除标志 folderName = './' # 获取指定路径的所有文件名字 dirList = os.listdir(folderName) # 遍历输出所有文件名字 for name in dirList: print(name) if funFlag == 1: newName = '[番号IPZ-972]-' + name elif funFlag == 2: num = len('[番号IPZ-972]-') newName = name[num:] print(newName) os.rename(folderName + name, folderName + newName) "},"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/wen-jian-de-sui-ji-du-xie.html":{"url":"primary/wen-jian-cao-zuo-3001-zong-he-ying-yong/wen-jian-de-sui-ji-du-xie.html","title":"作业","keywords":"","body":" 读取一个文件，显示除了以井号(#)开头的行以外的所有行 制作一个\"密码薄\",其可以存储一个网址（例如 www.itcast.cn），和一个密码(例如 123456)，请编写程序完成这个“密码薄”的增删改查功能，并且实现文件存储功能 "},"primary/mian-xiang-dui-xiang/mian-xiang-dui-xiang-bian-cheng-jie-shao.html":{"url":"primary/mian-xiang-dui-xiang/mian-xiang-dui-xiang-bian-cheng-jie-shao.html","title":"面向对象编程介绍","keywords":"","body":"面向对象编程介绍 想一想 面向对象编程介绍 想一想 请用程序描述如下事情： A同学报道登记信息 B同学报道登记信息 C同学报道登记信息 A同学做自我介绍 B同学做自我介绍 C同学做自我介绍 stu_a = { \"name\":\"A\", \"age\":21, \"gender\":1, \"hometown\":\"河北\" } stu_b = { \"name\":\"B\", \"age\":22, \"gender\":0, \"hometown\":\"山东\" } stu_c = { \"name\":\"C\", \"age\":20, \"gender\":1, \"hometown\":\"安徽\" } def stu_intro(stu): \"\"\"自我介绍\"\"\" for key, value in stu.items(): print(\"key=%s, value=%d\"%(key,value)) stu_intro(stu_a) stu_intro(stu_b) stu_intro(stu_c) 考虑现实生活中，我们的思维方式是放在学生这个个人上，是学生做了自我介绍。而不是像我们刚刚写出的代码，先有了介绍的行为，再去看介绍了谁。 用我们的现实思维方式该怎么用程序表达呢？ stu_a = Student(个人信息) stu_b = Student(个人信息) stu_c = Student(个人信息) stu_a.intro() stu_a.intro() stu_a.intro() 面向过程：根据业务逻辑从上到下写代码 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程 面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。 def 发送邮件(内容) #发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 while True： if cpu利用率 > 90%: 发送邮件('CPU报警') if 硬盘使用空间 > 90%: 发送邮件('硬盘报警') if 内存占用 > 80%: 发送邮件('内存报警') 今天我们来学习一种新的编程方式：面向对象编程（Object Oriented Programming，OOP，面向对象程序设计） 1）解决菜鸟买电脑的故事 第一种方式: 1)在网上查找资料 2)根据自己预算和需求定电脑的型号 MacBook 15 顶配 1W8 3)去市场找到苹果店各种店无法甄别真假 随便找了一家 4)找到业务员,业务员推荐了另外一款 配置更高价格便宜,也是苹果系统的 1W 5)砍价30分钟 付款9999 6)成交 回去之后发现各种问题 第二种方式 : 1)找一个靠谱的电脑高手 2)给钱交易 面向对象和面向过程都是解决问题的一种思路而已 买电脑的第一种方式: 强调的是步骤、过程、每一步都是自己亲自去实现的 这种解决问题的思路我们就叫做面向过程 买电脑的第二种方式: 强调的是电脑高手, 电脑高手是处理这件事的主角,对我们而言,我们并不必亲自实现整个步骤只需要调用电脑高手就可以解决问题 这种解决问题的思路就 是面向对象 用面向对象的思维解决问题的重点 当遇到一个需求的时候不用自己去实现，如果自己一步步实现那就是面向过程 应该找一个专门做这个事的人来做 面向对象是基于面向过程的 2）解决吃啤酒鸭的问题 第一种方式（面向过程）: 1)养鸭子 2)鸭子长成 3)杀 4)作料 5)烹饪 6)吃 7)卒 第二种方式（面向对象）: 1)找个卖啤酒鸭的人 2)给钱 交易 3)吃 4)胖6斤 需要了解的定义性文字: 面向对象(object-oriented ;简称: OO) 至今还没有统一的概念 我这里把它定义为: 按人们 认识客观世界的系统思维方式,采用基于对象(实体) 的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。 面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。 "},"primary/mian-xiang-dui-xiang/lei-he-dui-xiang.html":{"url":"primary/mian-xiang-dui-xiang/lei-he-dui-xiang.html","title":"类和对象","keywords":"","body":"类和对象 类 对象 类和对象之间的关系 练习：区分类和对象 类的构成 类的抽象 类和对象 面向对象编程的2个非常重要的概念：类和对象 对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——类 类就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于对象 类 人以类聚 物以群分。 具有相似内部状态和运动规律的实体的集合(或统称为抽象)。 具有相同属性和行为事物的统称 类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。一个类可以找到多个对象 对象 某一个具体事物的存在 ,在现实世界中可以是看得见摸得着的。 可以是直接使用的 类和对象之间的关系 小总结：类就是创建对象的模板 练习：区分类和对象 奔驰汽车 类 奔驰smart 类 张三的那辆奔驰smart 对象 狗 类 大黄狗 类 李四家那只大黄狗 对象 水果 类 苹果 类 红苹果 类 红富士苹果 类 我嘴里吃了一半的苹果 对象 类的构成 类(Class) 由3个部分构成 类的名称 :类名 类的属性 :一组数据 类的方法 :允许对进行操作的方法 (行为) 举例： 1）人类设计,只关心3样东西: 事物名称(类名):人(Person) 属性:身高(height)、年龄(age) 方法(行为/功能):跑(run)、打架(fight) 2）狗类的设计 类名:狗(Dog) 属性:品种 、毛色、性别、名字、 腿儿的数量 方法(行为/功能):叫 、跑、咬人、吃、摇尾巴 类的抽象 如何把日常生活中的事物抽象成程序中的类? 拥有相同(或者类似)属性和行为的对象都可以抽像出一个类 方法:一般名词都是类(名词提炼法) 坦克发射3颗炮弹轰掉了2架飞机 坦克--》可以抽象成 类 炮弹--》可以抽象成类 飞机-》可以抽象成类 小明在公车上牵着一条叼着热狗的狗 小明--》 人类 公车--》 交通工具类 热狗--》 食物类 狗--》 狗类 【想一想】如下图中，有哪些类呢？ 说明： 人 枪 子弹 手榴弹 刀子 箱子 【想一想】如下图中，有哪些类呢？ 说明: 向日葵 类名: xrk 属性: 行为: 放阳光 豌豆 类名: wd 属性: 颜色 、发型,血量 行为:发炮, 摇头 坚果: 类名:jg 属性:血量 类型 行为:阻挡; 僵尸: 类名:js 属性:颜色、血量、 类型、速度 行为:走 跑跳 吃 死 "},"primary/mian-xiang-dui-xiang/ding-yi-lei.html":{"url":"primary/mian-xiang-dui-xiang/ding-yi-lei.html","title":"定义类","keywords":"","body":"定义类 定义类 定义一个类，格式如下： class类名: 方法列表 demo：定义一个Car类 # 定义类 class Car: # 方法 def getCarInfo(self): print('车轮子个数:%d, 颜色%s'%(self.wheelNum, self.color)) def move(self): print(\"车正在移动...\") 说明： 定义类时有2种：新式类和经典类，上面的Car为经典类，如果是Car(object)则为新式类 类名 的命名规则按照\"大驼峰\" "},"primary/mian-xiang-dui-xiang/chuang-jian-dui-xiang.html":{"url":"primary/mian-xiang-dui-xiang/chuang-jian-dui-xiang.html","title":"创建对象","keywords":"","body":"创建对象 总结： 创建对象 通过上一节课程，定义了一个Car类；就好比有车一个张图纸，那么接下来就应该把图纸交给生成工人们去生成了 python中，可以根据已经定义的类去创建出一个个对象 创建对象的格式为: 对象名 = 类名() 创建对象demo: # 定义类 class Car: # 移动 def move(self): print('车在奔跑...') # 鸣笛 def toot(self): print(\"车在鸣笛...嘟嘟..\") # 创建一个对象，并用变量BMW来保存它的引用 BMW = Car() BMW.color = '黑色' BMW.wheelNum = 4 #轮子数量 BMW.move() BMW.toot() print(BMW.color) print(BMW.wheelNum) 总结： BMW = Car()，这样就产生了一个Car的实例对象，此时也可以通过实例对象BMW来访问属性或者方法 第一次使用BMW.color = '黑色'表示给BMW这个对象添加属性，如果后面再次出现BMW.color = xxx表示对属性进行修改 BMW是一个对象，它拥有属性（数据）和方法（函数） 当创建一个对象时，就是用一个模子，来制造一个实物 "},"primary/mian-xiang-dui-xiang/init-fang-fa.html":{"url":"primary/mian-xiang-dui-xiang/init-fang-fa.html","title":"__init__()方法","keywords":"","body":"__init__()方法 使用方式 __init__()方法的调用 想一想 __init__()方法 想一想: 在上一小节的demo中，我们已经给BMW这个对象添加了2个属性，wheelNum（车的轮胎数量）以及color（车的颜色），试想如果再次创建一个对象的话，肯定也需要进行添加属性，显然这样做很费事，那么有没有办法能够在创建对象的时候，就顺便把车这个对象的属性给设置呢？ 答: __init__()方法 使用方式 def 类名: #初始化函数，用来完成一些默认的设定 def __init__(): pass __init__()方法的调用 # 定义汽车类 class Car: def __init__(self): self.wheelNum = 4 self.color = '蓝色' def move(self): print('车在跑，目标:夏威夷') # 创建对象 BMW = Car() print('车的颜色为:%s'%BMW.color) print('车轮胎数量为:%d'%BMW.wheelNum) 总结1 当创建Car对象后，在没有调用__init__()方法的前提下，BMW就默认拥有了2个属性wheelNum和color，原因是__init__()方法是在创建对象后，就立刻被默认调用了 想一想 既然在创建完对象后__init__()方法已经被默认的执行了，那么能否让对象在调用__init__()方法的时候传递一些参数呢？如果可以，那怎样传递呢？ # 定义汽车类 class Car: def __init__(self, newWheelNum, newColor): self.wheelNum = newWheelNum self.color = newColor def move(self): print('车在跑，目标:夏威夷') # 创建对象 BMW = Car(4, 'green') print('车的颜色为:%s'%BMW.color) print('车轮子数量为:%d'%BMW.wheelNum) 总结2 __init__() 方法，在创建一个对象时默认被调用，不需要手动调用 __init__(self)中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么__init__(self)中出了self作为第一个形参外还需要2个形参，例如__init__(self,x,y) __init__(self) 中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去 "},"primary/mian-xiang-dui-xiang/mo-6cd522-fang-fa.html":{"url":"primary/mian-xiang-dui-xiang/mo-6cd522-fang-fa.html","title":"\"魔法\"方法","keywords":"","body":"\"魔法\"方法 打印id() 定义__str__()方法 总结 \"魔法\"方法 打印id() 如果把BMW使用print进行输出的话，会看到如下的信息 即看到的是创建出来的BMW对象在内存中的地址 定义__str__()方法 class Car: def __init__(self, newWheelNum, newColor): self.wheelNum = newWheelNum self.color = newColor def __str__(self): msg = \"嘿。。。我的颜色是\" + self.color + \"我有\" + int(self.wheelNum) + \"个轮胎...\" return msg def move(self): print('车在跑，目标:夏威夷') BMW = Car(4, \"白色\") print(BMW) 总结 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据 "},"primary/mian-xiang-dui-xiang/self.html":{"url":"primary/mian-xiang-dui-xiang/self.html","title":"self","keywords":"","body":"self 理解self 总结 self 理解self 看如下示例: # 定义一个类 class Animal: # 方法 def __init__(self, name): self.name = name def printName(self): print('名字为:%s'%self.name) # 定义一个函数 def myPrint(animal): animal.printName() dog1 = Animal('西西') myPrint(dog1) dog2 = Animal('北北') myPrint(dog2) 运行结果: 总结 所谓的self，可以理解为自己 可以把self当做C++中类里面的this指针一样理解，就是对象自身的意思 某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以开发者只需要传递后面的参数即可 "},"primary/mian-xiang-dui-xiang/ying-75283a-kao-di-gua.html":{"url":"primary/mian-xiang-dui-xiang/ying-75283a-kao-di-gua.html","title":"应用:烤地瓜","keywords":"","body":"应用:烤地瓜 分析“烤地瓜”的属性和方法 示例属性如下: 示例方法如下: 定义类，并且定义__init__()方法 添加\"烤地瓜\"方法 基本的功能已经有了一部分，赶紧测试一下 测试cook方法是否好用 定义addCondiments()方法和__str__()方法 再次测试 应用:烤地瓜 为了更好的理解面向对象编程，下面以“烤地瓜”为案例，进行分析 分析“烤地瓜”的属性和方法 示例属性如下: cookedLevel : 这是数字；0~3表示还是生的，超过3表示半生不熟，超过5表示已经烤好了，超过8表示已经烤成木炭了！我们的地瓜开始时时生的 cookedString : 这是字符串；描述地瓜的生熟程度 condiments : 这是地瓜的配料列表，比如番茄酱、芥末酱等 示例方法如下: cook() : 把地瓜烤一段时间 addCondiments() : 给地瓜添加配料 __init__() : 设置默认的属性 __str__() : 让print的结果看起来更好一些 定义类，并且定义__init__()方法 #定义`地瓜`类 class SweetPotato: '这是烤地瓜的类' #定义初始化方法 def __init__(self): self.cookedLevel = 0 self.cookedString = \"生的\" self.condiments = [] 添加\"烤地瓜\"方法 #烤地瓜方法 def cook(self, time): self.cookedLevel += time if self.cookedLevel > 8: self.cookedString = \"烤成灰了\" elif self.cookedLevel > 5: self.cookedString = \"烤好了\" elif self.cookedLevel > 3: self.cookedString = \"半生不熟\" else: self.cookedString = \"生的\" 基本的功能已经有了一部分，赶紧测试一下 把上面2块代码合并为一个程序后，在代码的下面添加以下代码进行测试 mySweetPotato = SweetPotato() print(mySweetPotato.cookedLevel) print(mySweetPotato.cookedString) print(mySweetPotato.condiments) 完整的代码为: class SweetPotato: '这是烤地瓜的类' #定义初始化方法 def __init__(self): self.cookedLevel = 0 self.cookedString = \"生的\" self.condiments = [] #烤地瓜方法 def cook(self, time): self.cookedLevel += time if self.cookedLevel > 8: self.cookedString = \"烤成灰了\" elif self.cookedLevel > 5: self.cookedString = \"烤好了\" elif self.cookedLevel > 3: self.cookedString = \"半生不熟\" else: self.cookedString = \"生的\" # 用来进行测试 mySweetPotato = SweetPotato() print(mySweetPotato.cookedLevel) print(mySweetPotato.cookedString) print(mySweetPotato.condiments) 测试cook方法是否好用 在上面的代码最后面添加如下代码: print(\"------接下来要进行烤地瓜了-----\") mySweetPotato.cook(4) #烤4分钟 print(mySweetPotato.cookedLevel) print(mySweetPotato.cookedString) 定义addCondiments()方法和__str__()方法 def __str__(self): msg = self.cookedString + \" 地瓜\" if len(self.condiments) > 0: msg = msg + \"(\" for temp in self.condiments: msg = msg + temp + \", \" msg = msg.strip(\", \") msg = msg + \")\" return msg def addCondiments(self, condiments): self.condiments.append(condiments) 再次测试 完整的代码如下: class SweetPotato: \"这是烤地瓜的类\" #定义初始化方法 def __init__(self): self.cookedLevel = 0 self.cookedString = \"生的\" self.condiments = [] #定制print时的显示内容 def __str__(self): msg = self.cookedString + \" 地瓜\" if len(self.condiments) > 0: msg = msg + \"(\" for temp in self.condiments: msg = msg + temp + \", \" msg = msg.strip(\", \") msg = msg + \")\" return msg #烤地瓜方法 def cook(self, time): self.cookedLevel += time if self.cookedLevel > 8: self.cookedString = \"烤成灰了\" elif self.cookedLevel > 5: self.cookedString = \"烤好了\" elif self.cookedLevel > 3: self.cookedString = \"半生不熟\" else: self.cookedString = \"生的\" #添加配料 def addCondiments(self, condiments): self.condiments.append(condiments) # 用来进行测试 mySweetPotato = SweetPotato() print(\"------有了一个地瓜，还没有烤-----\") print(mySweetPotato.cookedLevel) print(mySweetPotato.cookedString) print(mySweetPotato.condiments) print(\"------接下来要进行烤地瓜了-----\") print(\"------地瓜经烤了4分钟-----\") mySweetPotato.cook(4) #烤4分钟 print(mySweetPotato) print(\"------地瓜又经烤了3分钟-----\") mySweetPotato.cook(3) #又烤了3分钟 print(mySweetPotato) print(\"------接下来要添加配料-番茄酱------\") mySweetPotato.addCondiments(\"番茄酱\") print(mySweetPotato) print(\"------地瓜又经烤了5分钟-----\") mySweetPotato.cook(5) #又烤了5分钟 print(mySweetPotato) print(\"------接下来要添加配料-芥末酱------\") mySweetPotato.addCondiments(\"芥末酱\") print(mySweetPotato) "},"primary/mian-xiang-dui-xiang/yin-cang-shu-ju.html":{"url":"primary/mian-xiang-dui-xiang/yin-cang-shu-ju.html","title":"隐藏数据","keywords":"","body":"隐藏数据 隐藏数据 可能你已经意识到，查看过着修改对象的属性（数据），有2种方法 直接通过对象名修改 SweetPotato.cookedLevel = 5 通过方法间接修改 SweetPotato.cook(5) 分析 明明可以使用第1种方法直接修改，为什么还要定义方法来间接修改呢？ 至少有2个原因： 如果直接修改属性，烤地瓜至少需要修改2部分，即修改cookedLevel和cookedString。而使用方法来修改时，只需要调用一次即可完成 如果直接访问属性，可能会出现一些数据设置错误的情况产生例如cookedLevel = -3。这会使地瓜比以前还生，当然了这也没有任何意义，通过使用方法来进行修改，就可以在方法中进行数据合法性的检查 "},"primary/mian-xiang-dui-xiang/ying-75283a-cun-fang-jia-ju.html":{"url":"primary/mian-xiang-dui-xiang/ying-75283a-cun-fang-jia-ju.html","title":"应用:存放家具","keywords":"","body":"应用:存放家具 应用:存放家具 #定义一个home类 class Home: def __init__(self, area): self.area = area #房间剩余的可用面积 #self.light = 'on' #灯默认是亮的 self.containsItem = [] def __str__(self): msg = \"当前房间可用面积为:\" + str(self.area) if len(self.containsItem) > 0: msg = msg + \" 容纳的物品有: \" for temp in self.containsItem: msg = msg + temp.getName() + \", \" msg = msg.strip(\", \") return msg #容纳物品 def accommodateItem(self,item): #如果可用面积大于物品的占用面积 needArea = item.getUsedArea() if self.area > needArea: self.containsItem.append(item) self.area -= needArea print(\"ok:已经存放到房间中\") else: print(\"err:房间可用面积为:%d,但是当前要存放的物品需要的面积为%d\"%(self.area, needArea)) #定义bed类 class Bed: def __init__(self,area,name = '床'): self.name = name self.area = area def __str__(self): msg = '床的面积为:' + str(self.area) return msg #获取床的占用面积 def getUsedArea(self): return self.area def getName(self): return self.name #创建一个新家对象 newHome = Home(100)#100平米 print(newHome) #创建一个床对象 newBed = Bed(20) print(newBed) #把床安放到家里 newHome.accommodateItem(newBed) print(newHome) #创建一个床对象 newBed2 = Bed(30,'席梦思') print(newBed2) #把床安放到家里 newHome.accommodateItem(newBed2) print(newHome) 总结： 如果一个对象与另外一个对象有一定的关系，那么一个对象可用是另外一个对象的属性 思维升华： 添加“开、关”灯，让房间、床一起亮、灭 "},"primary/mian-xiang-dui-xiang-2/lao-wang-kai-qiang.html":{"url":"primary/mian-xiang-dui-xiang-2/lao-wang-kai-qiang.html","title":"应用：老王开枪","keywords":"","body":"应用：老王开枪 应用：老王开枪 1. 人类 属性 姓名 血量 持有的枪 方法 安子弹 安弹夹 拿枪（持有抢） 开枪 2. 子弹类 属性 杀伤力 方法 伤害敌人(让敌人掉血) 3. 弹夹类 属性 容量（子弹存储的最大值） 当前保存的子弹 方法 保存子弹（安装子弹的时候） 弹出子弹（开枪的时候） 4. 枪类 属性 弹夹（默认没有弹夹，需要安装） 方法 连接弹夹（保存弹夹） 射子弹 参考代码 #人类 class Ren: def __init__(self,name): self.name = name self.xue = 100 self.qiang = None def __str__(self): return self.name + \"剩余血量为:\" + str(self.xue) def anzidan(self,danjia,zidan): danjia.baocunzidan(zidan) def andanjia(self,qiang,danjia): qiang.lianjiedanjia(danjia) def naqiang(self,qiang): self.qiang = qiang def kaiqiang(self,diren): self.qiang.she(diren) def diaoxue(self,shashangli): self.xue -= shashangli #弹夹类 class Danjia: def __init__(self, rongliang): self.rongliang = rongliang self.rongnaList = [] def __str__(self): return \"弹夹当前的子弹数量为:\" + str(len(self.rongnaList)) + \"/\" + str(self.rongliang) def baocunzidan(self,zidan): if len(self.rongnaList) 0: #获取最后压入到单间中的子弹 zidan = self.rongnaList[-1] self.rongnaList.pop() return zidan else: return None #子弹类 class Zidan: def __init__(self,shashangli): self.shashangli = shashangli def shanghai(self,diren): diren.diaoxue(self.shashangli) #枪类 class Qiang: def __init__(self): self.danjia = None def __str__(self): if self.danjia: return \"枪当前有弹夹\" else: return \"枪没有弹夹\" def lianjiedanjia(self,danjia): if not self.danjia: self.danjia = danjia def she(self,diren): zidan = self.danjia.chuzidan() if zidan: zidan.shanghai(diren) else: print(\"没有子弹了，放了空枪....\") #创建一个人对象 laowang = Ren(\"老王\") #创建一个弹夹 danjia = Danjia(20) print(danjia) #循环的方式创建一颗子弹，然后让老王把这颗子弹压入到弹夹中 i=0 while i "},"primary/mian-xiang-dui-xiang-2/bao-hu-dui-xiang-de-shu-xing.html":{"url":"primary/mian-xiang-dui-xiang-2/bao-hu-dui-xiang-de-shu-xing.html","title":"保护对象的属性","keywords":"","body":"保护对象的属性 保护对象的属性 如果有一个对象，当需要对其进行修改属性时，有2种方法 对象名.属性名 = 数据 ---- > 直接修改 对象名.方法名() ---- > 间接修改 为了更好的保存属性安全，即不能随意修改，一般的处理方式为 将属性定义为私有属性 添加一个可以调用的方法，供调用 class People(object): def __init__(self, name): self.__name = name def getName(self): return self.__name def setName(self, newName): if len(newName) >= 5: self.__name = newName else: print(\"error:名字长度需要大于或者等于5\") xiaoming = People(\"dongGe\") print(xiaoming.__name) class People(object): def __init__(self, name): self.__name = name def getName(self): return self.__name def setName(self, newName): if len(newName) >= 5: self.__name = newName else: print(\"error:名字长度需要大于或者等于5\") xiaoming = People(\"dongGe\") xiaoming.setName(\"wanger\") print(xiaoming.getName()) xiaoming.setName(\"lisi\") print(xiaoming.getName()) 总结 Python中没有像C++中public和private这些关键字来区别公有属性和私有属性 它是以属性命名方式来区分，如果在属性名前面加了2个下划线'__'，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。 "},"primary/mian-xiang-dui-xiang-2/del-fang-fa.html":{"url":"primary/mian-xiang-dui-xiang-2/del-fang-fa.html","title":"__del__()方法","keywords":"","body":"__del__()方法 __del__()方法 创建对象后，python解释器默认调用__init__()方法； 当删除一个对象时，python解释器也会默认调用一个方法，这个方法为__del__()方法 import time class Animal(object): # 初始化方法 # 创建完对象后会自动被调用 def __init__(self, name): print('__init__方法被调用') self.__name = name # 析构方法 # 当对象被删除时，会自动被调用 def __del__(self): print(\"__del__方法被调用\") print(\"%s对象马上被干掉了...\"%self.__name) # 创建对象 dog = Animal(\"哈皮狗\") # 删除对象 del dog cat = Animal(\"波斯猫\") cat2 = cat cat3 = cat print(\"---马上 删除cat对象\") del cat print(\"---马上 删除cat2对象\") del cat2 print(\"---马上 删除cat3对象\") del cat3 print(\"程序2秒钟后结束\") time.sleep(2) 结果: 总结 当有1个变量保存了对象的引用时，此对象的引用计数就会加1 当使用del删除变量指向的对象时，如果对象的引用计数不会1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除 "},"primary/mian-xiang-dui-xiang-2/ji-cheng-jie-shao-yi-ji-dan-ji-cheng.html":{"url":"primary/mian-xiang-dui-xiang-2/ji-cheng-jie-shao-yi-ji-dan-ji-cheng.html","title":"继承介绍以及单继承","keywords":"","body":"继承介绍以及单继承 1. 继承的概念 2. 继承示例 3. 注意点 继承介绍以及单继承 1. 继承的概念 在现实生活中，继承一般指的是子女继承父辈的财产，如下图 搞不好,结果如下.. 在程序中，继承描述的是事物之间的所属关系，例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物；同理，波斯猫和巴厘猫都继承自猫，而沙皮狗和斑点狗都继承足够，如下如所示： 2. 继承示例 # 定义一个父类，如下: class Cat(object): def __init__(self, name, color=\"白色\"): self.name = name self.color = color def run(self): print(\"%s--在跑\"%self.name) # 定义一个子类，继承Cat类如下: class Bosi(Cat): def setNewName(self, newName): self.name = newName def eat(self): print(\"%s--在吃\"%self.name) bs = Bosi(\"印度猫\") print('bs的名字为:%s'%bs.name) print('bs的颜色为:%s'%bs.color) bs.eat() bs.setNewName('波斯') bs.run() 运行结果: 说明： 虽然子类没有定义 __init__ 方法，但是父类有，所以在子类继承父类的时候这个方法就被继承了，所以只要创建Bosi的对象，就默认执行了那个继承过来的 __init__ 方法 总结 子类在继承的时候，在定义类时，小括号()中为父类的名字 父类的属性、方法，会被继承给子类 3. 注意点 class Animal(object): def __init__(self, name='动物', color='白色'): self.__name = name self.color = color def __test(self): print(self.__name) print(self.color) def test(self): print(self.__name) print(self.color) class Dog(Animal): def dogTest1(self): #print(self.__name) #不能访问到父类的私有属性 print(self.color) def dogTest2(self): #self.__test() #不能访问父类中的私有方法 self.test() A = Animal() #print(A.__name) #程序出现异常，不能访问私有属性 print(A.color) #A.__test() #程序出现异常，不能访问私有方法 A.test() print(\"------分割线-----\") D = Dog(name = \"小花狗\", color = \"黄色\") D.dogTest1() D.dogTest2() 私有的属性，不能通过对象直接访问，但是可以通过方法访问 私有的方法，不能通过对象直接访问 私有的属性、方法，不会被子类继承，也不能被访问 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用 "},"primary/mian-xiang-dui-xiang-2/duo-ji-cheng.html":{"url":"primary/mian-xiang-dui-xiang-2/duo-ji-cheng.html","title":"多继承","keywords":"","body":"多继承 1. 多继承 注意点 多继承 1. 多继承 从图中能够看出，所谓多继承，即子类有多个父类，并且具有它们的特征 Python中多继承的格式如下: # 定义一个父类 class A: def printA(self): print('----A----') # 定义一个父类 class B: def printB(self): print('----B----') # 定义一个子类，继承自A、B class C(A,B): def printC(self): print('----C----') obj_C = C() obj_C.printA() obj_C.printB() 运行结果: ----A---- ----B---- 说明 python中是可以多继承的 父类中的方法、属性，子类会继承 注意点 想一想: 如果在上面的多继承例子中，如果父类A和父类B中，有一个同名的方法，那么通过子类去调用的时候，调用哪个？ #coding=utf-8 class base(object): def test(self): print('----base test----') class A(base): def test(self): print('----A test----') # 定义一个父类 class B(base): def test(self): print('----B test----') # 定义一个子类，继承自A、B class C(A,B): pass obj_C = C() obj_C.test() print(C.__mro__) #可以查看C类的对象搜索方法时的先后顺序 "},"primary/mian-xiang-dui-xiang-2/zhong-xie-fu-lei-fang-fa-yu-diao-yong-fu-lei-fang-fa.html":{"url":"primary/mian-xiang-dui-xiang-2/zhong-xie-fu-lei-fang-fa-yu-diao-yong-fu-lei-fang-fa.html","title":"重写父类方法与调用父类方法","keywords":"","body":"重写父类方法与调用父类方法 1. 重写父类方法 2. 调用父类的方法 重写父类方法与调用父类方法 1. 重写父类方法 所谓重写，就是子类中，有一个和父类相同名字的方法，在子类中的方法会覆盖掉父类中同名的方法 #coding=utf-8 class Cat(object): def sayHello(self): print(\"halou-----1\") class Bosi(Cat): def sayHello(self): print(\"halou-----2\") bosi = Bosi() bosi.sayHello() 2. 调用父类的方法 #coding=utf-8 class Cat(object): def __init__(self,name): self.name = name self.color = 'yellow' class Bosi(Cat): def __init__(self,name): # 调用父类的__init__方法1(python2) #Cat.__init__(self,name) # 调用父类的__init__方法2 #super(Bosi,self).__init__(name) # 调用父类的__init__方法3 super().__init__(name) def getName(self): return self.name bosi = Bosi('xiaohua') print(bosi.name) print(bosi.color) "},"primary/mian-xiang-dui-xiang-2/duo-tai.html":{"url":"primary/mian-xiang-dui-xiang-2/duo-tai.html","title":"多态","keywords":"","body":"多态 多态 多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型”。 所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态 Python伪代码实现Java或C#的多态 class F1(object): def show(self): print 'F1.show' class S1(F1): def show(self): print 'S1.show' class S2(F1): def show(self): print 'S2.show' # 由于在Java或C#中定义函数参数时，必须指定参数的类型 # 为了让Func函数既可以执行S1对象的show方法，又可以执行S2对象的show方法，所以，定义了一个S1和S2类的父类 # 而实际传入的参数是：S1对象和S2对象 def Func(F1 obj): \"\"\"Func函数需要接收一个F1类型或者F1子类的类型\"\"\" print obj.show() s1_obj = S1() Func(s1_obj) # 在Func函数中传入S1类的对象 s1_obj，执行 S1 的show方法，结果：S1.show s2_obj = S2() Func(s2_obj) # 在Func函数中传入Ss类的对象 ss_obj，执行 Ss 的show方法，结果：S2.show Python “鸭子类型” class F1(object): def show(self): print 'F1.show' class S1(F1): def show(self): print 'S1.show' class S2(F1): def show(self): print 'S2.show' def Func(obj): print obj.show() s1_obj = S1() Func(s1_obj) s2_obj = S2() Func(s2_obj) "},"primary/mian-xiang-dui-xiang-2/lei-shu-xing-3001-shi-li-shu-xing.html":{"url":"primary/mian-xiang-dui-xiang-2/lei-shu-xing-3001-shi-li-shu-xing.html","title":"类属性、实例属性","keywords":"","body":"类属性、实例属性 类属性 实例属性(对象属性) 通过实例(对象)去修改类属性 总结 类属性、实例属性 在了解了类基本的东西之后，下面看一下python中这几个概念的区别 先来谈一下类属性和实例属性 在前面的例子中我们接触到的就是实例属性（对象属性），顾名思义，类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本，这个和C++中类的静态成员变量有点类似。对于公有的类属性，在类外可以通过类对象和实例对象访问 类属性 class People(object): name = 'Tom' #公有的类属性 __age = 12 #私有的类属性 p = People() print(p.name) #正确 print(People.name) #正确 print(p.__age) #错误，不能在类外通过实例对象访问私有的类属性 print(People.__age) #错误，不能在类外通过类对象访问私有的类属性 实例属性(对象属性) class People(object): address = '山东' #类属性 def __init__(self): self.name = 'xiaowang' #实例属性 self.age = 20 #实例属性 p = People() p.age =12 #实例属性 print(p.address) #正确 print(p.name) #正确 print(p.age) #正确 print(People.address) #正确 print(People.name) #错误 print(People.age) #错误 通过实例(对象)去修改类属性 class People(object): country = 'china' #类属性 print(People.country) p = People() print(p.country) p.country = 'japan' print(p.country) #实例属性会屏蔽掉同名的类属性 print(People.country) del p.country #删除实例属性 print(p.country) 总结 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。 "},"primary/mian-xiang-dui-xiang-2/jing-tai-fang-fa-he-lei-fang-fa.html":{"url":"primary/mian-xiang-dui-xiang-2/jing-tai-fang-fa-he-lei-fang-fa.html","title":"静态方法和类方法","keywords":"","body":"静态方法和类方法 1. 类方法 2. 静态方法 总结 静态方法和类方法 1. 类方法 是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以'cls'作为第一个参数的名字，就最好用'cls'了），能够通过实例对象和类对象去访问。 class People(object): country = 'china' #类方法，用classmethod来进行修饰 @classmethod def getCountry(cls): return cls.country p = People() print p.getCountry() #可以用过实例对象引用 print People.getCountry() #可以通过类对象引用 类方法还有一个用途就是可以对类属性进行修改： class People(object): country = 'china' #类方法，用classmethod来进行修饰 @classmethod def getCountry(cls): return cls.country @classmethod def setCountry(cls,country): cls.country = country p = People() print p.getCountry() #可以用过实例对象引用 print People.getCountry() #可以通过类对象引用 p.setCountry('japan') print p.getCountry() print People.getCountry() 结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变 2. 静态方法 需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数 class People(object): country = 'china' @staticmethod #静态方法 def getCountry(): return People.country print People.getCountry() 总结 从类方法和实例方法以及静态方法的定义形式就可以看出来，类方法的第一个参数是类对象cls，那么通过cls引用的必定是类对象的属性和方法；而实例方法的第一个参数是实例对象self，那么通过self引用的可能是类属性、也有可能是实例属性（这个需要具体分析），不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类对象来引用 "},"primary/mian-xiang-dui-xiang-3/lian-xi-ff1a-she-ji-lei.html":{"url":"primary/mian-xiang-dui-xiang-3/lian-xi-ff1a-she-ji-lei.html","title":"练习：设计类","keywords":"","body":"练习：设计类 1. 设计一个卖车的4S店，该怎样做呢？ 说明 2. 设计一个卖北京现代车的4S店 练习：设计类 1. 设计一个卖车的4S店，该怎样做呢？ # 定义车类 class Car(object): # 定义车的方法 def move(self): print(\"---车在移动---\") def stop(self): print(\"---停车---\") # 定义一个销售车的店类 class CarStore(object): def order(self): self.car = Car() #找一辆车 self.car.move() self.car.stop() 说明 上面的4s店，只能销售那一种类型的车 如果这个是个销售北京现代品牌的车，比如伊兰特、索纳塔等，该怎样做呢？ 2. 设计一个卖北京现代车的4S店 # 定义伊兰特车类 class YilanteCar(object): # 定义车的方法 def move(self): print(\"---车在移动---\") def stop(self): print(\"---停车---\") # 定义索纳塔车类 class SuonataCar(object): # 定义车的方法 def move(self): print(\"---车在移动---\") def stop(self): print(\"---停车---\") # 定义一个销售北京现代车的店类 class CarStore(object): def order(self, typeName): #根据客户的不同要求，生成不同的类型的车 if typeName == \"伊兰特\": car = YilanteCar() elif typeName == \"索纳塔\": car = SuonataCar() return car 这样做，不太好，因为当北京现代又生产一种新类型的车时，又得在CarStore类中修改，有没有好的解决办法呢？ "},"primary/mian-xiang-dui-xiang-3/gong-chang-mo-shi.html":{"url":"primary/mian-xiang-dui-xiang-3/gong-chang-mo-shi.html","title":"工厂模式","keywords":"","body":"工厂模式 简单工厂模式 在上一节中，最后留下的个问题，该怎样解决呢？ 使用函数实现 使用类来实现 工厂方法模式 多种品牌的汽车4S店 最后来看看工厂方法模式的定义 工厂模式 简单工厂模式 在上一节中，最后留下的个问题，该怎样解决呢？ 使用函数实现 # 定义伊兰特车类 class YilanteCar(object): # 定义车的方法 def move(self): print(\"---车在移动---\") def stop(self): print(\"---停车---\") # 定义索纳塔车类 class SuonataCar(object): # 定义车的方法 def move(self): print(\"---车在移动---\") def stop(self): print(\"---停车---\") # 用来生成具体的对象 def createCar(typeName): if typeName == \"伊兰特\": car = YilanteCar() elif typeName == \"索纳塔\": car = SuonataCar() return car # 定义一个销售北京现代车的店类 class CarStore(object): def order(self, typeName): # 让工厂根据类型，生产一辆汽车 car = createCar(typeName) return car 使用类来实现 # 定义伊兰特车类 class YilanteCar(object): # 定义车的方法 def move(self): print(\"---车在移动---\") def stop(self): print(\"---停车---\") # 定义索纳塔车类 class SuonataCar(object): # 定义车的方法 def move(self): print(\"---车在移动---\") def stop(self): print(\"---停车---\") # 定义一个生产汽车的工厂，让其根据具体的订单生产车 class CarFactory(object): def createCar(self,typeName): if typeName == \"伊兰特\": car = YilanteCar() elif typeName == \"索纳塔\": car = SuonataCar() return car # 定义一个销售北京现代车的店类 class CarStore(object): def __init__(self): #设置4s店的指定生产汽车的工厂 self.carFactory = CarFactory() def order(self, typeName): # 让工厂根据类型，生产一辆汽车 car = self.carFactory.createCar(typeName) return car 咋一看来，好像只是把生产环节重新创建了一个类，这确实比较像是一种编程习惯，此种解决方式被称作简单工厂模式 工厂函数、工厂类对具体的生成环节进行了封装，这样有利于代码的后需扩展，即把功能划分的更具体，4s店只负责销售，汽车厂只负责制造 工厂方法模式 多种品牌的汽车4S店 当买车时，有很多种品牌可以选择，比如北京现代、别克、凯迪拉克、特斯拉等，那么此时该怎样进行设计呢？ # 定义一个基本的4S店类 class CarStore(object): #仅仅是定义了有这个方法，并没有实现，具体功能，这个需要在子类中实现 def createCar(self, typeName): pass def order(self, typeName): # 让工厂根据类型，生产一辆汽车 self.car = self.createCar(typeName) self.car.move() self.car.stop() # 定义一个北京现代4S店类 class XiandaiCarStore(CarStore): def createCar(self, typeName): self.carFactory = CarFactory() return self.carFactory.createCar(typeName) # 定义伊兰特车类 class YilanteCar(object): # 定义车的方法 def move(self): print(\"---车在移动---\") def stop(self): print(\"---停车---\") # 定义索纳塔车类 class SuonataCar(object): # 定义车的方法 def move(self): print(\"---车在移动---\") def stop(self): print(\"---停车---\") # 定义一个生产汽车的工厂，让其根据具体得订单生产车 class CarFactory(object): def createCar(self,typeName): self.typeName = typeName if self.typeName == \"伊兰特\": self.car = YilanteCar() elif self.typeName == \"索纳塔\": self.car = SuonataCar() return self.car suonata = XiandaiCarStore() suonata.order(\"索纳塔\") 最后来看看工厂方法模式的定义 定义了一个创建对象的接口(可以理解为函数)，但由子类决定要实例化的类是哪一个，工厂方法模式让类的实例化推迟到子类，抽象的CarStore提供了一个创建对象的方法createCar，也叫作工厂方法。 子类真正实现这个createCar方法创建出具体产品。 创建者类不需要直到实际创建的产品是哪一个，选择了使用了哪个子类，自然也就决定了实际创建的产品是什么。 "},"primary/mian-xiang-dui-xiang-3/new-fang-fa.html":{"url":"primary/mian-xiang-dui-xiang-3/new-fang-fa.html","title":"__new__方法","keywords":"","body":"__new__方法 __new__和__init__的作用 注意点 __new__方法 __new__和__init__的作用 class A(object): def __init__(self): print(\"这是 init 方法\") def __new__(cls): print(\"这是 new 方法\") return object.__new__(cls) A() 总结 __new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供 __new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例 __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值 我们可以将类比作制造商，__new__方法就是前期的原材料购买环节，__init__方法就是在有原材料的基础上，加工，初始化商品环节 注意点 "},"primary/mian-xiang-dui-xiang-3/dan-li-mo-shi.html":{"url":"primary/mian-xiang-dui-xiang-3/dan-li-mo-shi.html","title":"单例模式","keywords":"","body":"单例模式 单例是什么 创建单例-保证只有1个对象 创建单例时，只执行1次__init__方法 单例模式 单例是什么 举个常见的单例模式例子，我们日常使用的电脑上都有一个回收站，在整个操作系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，而且回收站自行提供自己的实例。因此回收站是单例模式的应用。 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式。 创建单例-保证只有1个对象 # 实例化一个单例 class Singleton(object): __instance = None def __new__(cls, age, name): #如果类数字能够__instance没有或者没有赋值 #那么就创建一个对象，并且赋值为这个对象的引用，保证下次调用这个方法时 #能够知道之前已经创建过对象了，这样就保证了只有1个对象 if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instance a = Singleton(18, \"dongGe\") b = Singleton(8, \"dongGe\") print(id(a)) print(id(b)) a.age = 19 #给a指向的对象添加一个属性 print(b.age)#获取b指向的对象的age属性 运行结果： In [12]: class Singleton(object): ...: __instance = None ...: ...: def __new__(cls, age, name): ...: if not cls.__instance: ...: cls.__instance = object.__new__(cls) ...: return cls.__instance ...: ...: a = Singleton(18, \"dongGe\") ...: b = Singleton(8, \"dongGe\") ...: ...: print(id(a)) ...: print(id(b)) ...: ...: a.age = 19 ...: print(b.age) ...: 4391023224 4391023224 19 创建单例时，只执行1次__init__方法 # 实例化一个单例 class Singleton(object): __instance = None __first_init = False def __new__(cls, age, name): if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instance def __init__(self, age, name): if not self.__first_init: self.age = age self.name = name Singleton.__first_init = True a = Singleton(18, \"dongGe\") b = Singleton(8, \"dongGe\") print(id(a)) print(id(b)) print(a.age) print(b.age) a.age = 19 print(b.age) 运行结果: "},"primary/mian-xiang-dui-xiang-3/yi-chang-jie-shao.html":{"url":"primary/mian-xiang-dui-xiang-3/yi-chang-jie-shao.html","title":"异常介绍","keywords":"","body":"异常 异常简介 异常 异常简介 看如下示例: print '-----test--1---' open('123.txt','r') print '-----test--2---' 运行结果: 说明: 打开一个不存在的文件123.txt，当找不到123.txt 文件时，就会抛出给我们一个IOError类型的错误，No such file or directory：123.txt （没有123.txt这样的文件或目录） 异常: 当Python检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的\"异常\" "},"primary/mian-xiang-dui-xiang-3/bu-huo-yi-chang.html":{"url":"primary/mian-xiang-dui-xiang-3/bu-huo-yi-chang.html","title":"捕获异常","keywords":"","body":"案例剖析 捕获异常 try...except... except捕获多个异常 注意： 获取异常的信息描述 捕获所有异常 else try...finally... 案例剖析 捕获异常 try...except... 看如下示例: try: print('-----test--1---') open('123.txt','r') print('-----test--2---') except IOError: pass 运行结果: 说明: 此程序看不到任何错误，因为用except 捕获到了IOError异常，并添加了处理的方法 pass 表示实现了相应的实现，但什么也不做；如果把pass改为print语句，那么就会输出其他信息 小总结: 把可能出现问题的代码，放在try中 把处理异常的代码，放在except中 except捕获多个异常 看如下示例: try: print num except IOError: print('产生错误了') 运行结果如下: 想一想: 上例程序，已经使用except来捕获异常了，为什么还会看到错误的信息提示？ 答: except捕获的错误类型是IOError，而此时程序产生的异常为 NameError ，所以except没有生效 修改后的代码为: try: print num except NameError: print('产生错误了') 运行结果如下: 实际开发中，捕获多个异常的方式，如下： #coding=utf-8 try: print('-----test--1---') open('123.txt','r') # 如果123.txt文件不存在，那么会产生 IOError 异常 print('-----test--2---') print(num)# 如果num变量没有定义，那么会产生 NameError 异常 except (IOError,NameError): #如果想通过一次except捕获到多个异常可以用一个元组的方式 # errorMsg里会保存捕获到的错误信息 print(errorMsg) 注意： 当捕获多个异常时，可以把要捕获的异常的名字，放到except 后，并使用元组的方式仅进行存储 获取异常的信息描述 捕获所有异常 else 咱们应该对else并不陌生，在if中，它的作用是当条件不满足时执行的实行；同样在try...except...中也是如此，即如果没有捕获到异常，那么就执行else中的事情 try: num = 100 print num except NameError as errorMsg: print('产生错误了:%s'%errorMsg) else: print('没有捕获到异常，真高兴') 运行结果如下: try...finally... try...finally...语句用来表达这样的情况： 在程序中，如果一个段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用finally。 比如文件关闭，释放锁，把数据库连接返还给连接池等 demo: import time try: f = open('test.txt') try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) except: #如果在读取文件的过程中，产生了异常，那么就会捕获到 #比如 按下了 ctrl+c pass finally: f.close() print('关闭文件') except: print(\"没有这个文件\") 说明: test.txt文件中每一行数据打印，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些。在程序运行的时候，按Ctrl+c中断（取消）程序。 我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，finally从句仍然被执行，把文件关闭。 "},"primary/mian-xiang-dui-xiang-3/yi-chang-de-chuan-di.html":{"url":"primary/mian-xiang-dui-xiang-3/yi-chang-de-chuan-di.html","title":"异常的传递","keywords":"","body":"异常的传递 try嵌套中 函数嵌套调用中 异常的传递 try嵌套中 import time try: f = open('test.txt') try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) finally: f.close() print('关闭文件') except: print(\"没有这个文件\") 运行结果: In [26]: import time ...: try: ...: f = open('test.txt') ...: try: ...: while True: ...: content = f.readline() ...: if len(content) == 0: ...: break ...: time.sleep(2) ...: print(content) ...: finally: ...: f.close() ...: print('关闭文件') ...: except: ...: print(\"没有这个文件\") ...: finally: ...: print(\"最后的finally\") ...: xxxxxxx--->这是test.txt文件中读取到信息 ^C关闭文件 没有这个文件 最后的finally 函数嵌套调用中 def test1(): print(\"----test1-1----\") print(num) print(\"----test1-2----\") def test2(): print(\"----test2-1----\") test1() print(\"----test2-2----\") def test3(): try: print(\"----test3-1----\") test1() print(\"----test3-2----\") except Exception as result: print(\"捕获到了异常，信息是:%s\"%result) print(\"----test3-2----\") test3() print(\"------华丽的分割线-----\") test2() 运行结果: 总结： 如果try嵌套，那么如果里面的try没有捕获到这个异常，那么外面的try会接收到这个异常，然后进行处理，如果外边的try依然没有捕获到，那么再进行传递。。。 如果一个异常是在一个函数中产生的，例如函数A---->函数B----> 函数C,而异常是在函数C中产生的，那么如果函数C中没有对这个异常进行处理，那么这个异常会传递到函数B中，如果函数B有异常处理那么就会按照函数B的处理方式进行执行；如果函数B也没有异常处理，那么这个异常会继续传递，以此类推。。。如果所有的函数都没有处理，那么此时就会进行异常的默认处理，即通常见到的那样 注意观察上图中，当调用test3函数时，在test1函数内部产生了异常，此异常被传递到test3函数中完成了异常处理，而当异常处理完后，并没有返回到函数test1中进行执行，而是在函数test3中继续执行 "},"primary/mian-xiang-dui-xiang-3/pao-chu-zi-ding-yi-de-yi-chang.html":{"url":"primary/mian-xiang-dui-xiang-3/pao-chu-zi-ding-yi-de-yi-chang.html","title":"抛出自定义的异常","keywords":"","body":"抛出自定义的异常 抛出自定义的异常 你可以用raise语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是Error或Exception类的子类 下面是一个引发异常的例子: class ShortInputException(Exception): '''自定义的异常类''' def __init__(self, length, atleast): #super().__init__() self.length = length self.atleast = atleast def main(): try: s = input('请输入 --> ') if len(s) 运行结果如下: 注意 以上程序中，关于代码#super().__init__()的说明 这一行代码，可以调用也可以不调用，建议调用，因为__init__方法往往是用来对创建完的对象进行初始化工作，如果在子类中重写了父类的__init__方法，即意味着父类中的很多初始化工作没有做，这样就不保证程序的稳定了，所以在以后的开发中，如果重写了父类的__init__方法，最好是先调用父类的这个方法，然后再添加自己的功能 "},"primary/mian-xiang-dui-xiang-3/yi-chang-chu-li-zhong-pao-chu-yi-chang.html":{"url":"primary/mian-xiang-dui-xiang-3/yi-chang-chu-li-zhong-pao-chu-yi-chang.html","title":"异常处理中抛出异常","keywords":"","body":"异常处理中抛出异常 异常处理中抛出异常 class Test(object): def __init__(self, switch): self.switch = switch #开关 def calc(self, a, b): try: return a/b except Exception as result: if self.switch: print(\"捕获开启，已经捕获到了异常，信息如下:\") print(result) else: #重新抛出这个异常，此时就不会被这个异常处理给捕获到，从而触发默认的异常处理 raise a = Test(True) a.calc(11,0) print(\"----------------------华丽的分割线----------------\") a.switch = False a.calc(11,0) 运行结果: "},"primary/mian-xiang-dui-xiang-3/mo-kuai.html":{"url":"primary/mian-xiang-dui-xiang-3/mo-kuai.html","title":"模块","keywords":"","body":"模块 Python中的模块 import from…import 注意 from … import * 注意 as 定位模块 模块 Python中的模块 有过C语言编程经验的朋友都知道在C语言中如果要引用sqrt函数，必须用语句#include 引入math.h这个头文件，否则是无法正常进行调用的。 那么在Python中，如果要引用一些其他的函数，该怎么处理呢？ 在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包很类似，比如在Python中要调用sqrt函数，必须用import关键字引入math这个模块，下面就来了解一下Python中的模块。 说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块 import 在Python中用关键字import来引入某个模块，比如要引用模块math，就可以在文件最开始的地方用import math来引入。 形如: import module1,mudule2... 当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。 在调用math模块中的函数时，必须这样引用： 　　模块名.函数名 想一想: 为什么必须加上模块名调用呢？ 答: 因为可能存在这样一种情况：在多个模块中含有相同名称的函数，此时如果只是通过函数名来调用，解释器无法知道到底要调用哪个函数。所以如果像上述这样引入模块的时候，调用函数必须加上模块名 import math #这样会报错 print sqrt(2) #这样才能正确输出结果 print math.sqrt(2) 有时候我们只需要用到模块中的某个函数，只需要引入该函数即可，此时可以用下面方法实现： from 模块名 import 函数名1,函数名2.... 不仅可以引入函数，还可以引入一些全局变量、类等 注意: 通过这种方式引入的时候，调用函数时只能给出函数名，不能给出模块名，但是当两个模块中含有相同名称函数的时候，后面一次引入会覆盖前一次引入。也就是说假如模块A中有函数function( )，在模块B中也有函数function( )，如果引入A中的function在先、B中的function在后，那么当调用function函数的时候，是去执行模块B中的function函数。 如果想一次性引入math中所有的东西，还可以通过from math import *来实现 from…import Python的from语句让你从模块中导入一个指定的部分到当前命名空间中 语法如下： from modname import name1[, name2[, ... nameN]] 例如，要导入模块fib的fibonacci函数，使用如下语句： from fib import fibonacci 注意 不会把整个fib模块导入到当前的命名空间中，它只会将fib里的fibonacci单个引入 from … import * 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： from modname import * 注意 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。 as In [1]: import time as tt In [2]: time.sleep(1) --------------------------------------------------------------------------- NameError Traceback (most recent call last) in () ----> 1 time.sleep(1) NameError: name 'time' is not defined In [3]: In [3]: In [3]: tt.sleep(1) In [4]: In [4]: In [4]: from time import sleep as sp In [5]: sleep(1) --------------------------------------------------------------------------- NameError Traceback (most recent call last) in () ----> 1 sleep(1) NameError: name 'sleep' is not defined In [6]: In [6]: In [6]: sp(1) In [7]: 定位模块 当你导入一个模块，Python解析器对模块位置的搜索顺序是： 当前目录 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/ 模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 "},"primary/mian-xiang-dui-xiang-3/mo-kuai-zhi-zuo.html":{"url":"primary/mian-xiang-dui-xiang-3/mo-kuai-zhi-zuo.html","title":"模块制作","keywords":"","body":"模块制作 定义自己的模块 调用自己定义的模块 测试模块 直接运行此文件 在其他文件中import此文件 模块制作 定义自己的模块 在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。 比如有这样一个文件test.py，在test.py中定义了函数add test.py def add(a,b): return a+b 调用自己定义的模块 那么在其他文件中就可以先import test，然后通过test.add(a,b)来调用了，当然也可以通过from test import add来引入 main.py import test result = test.add(11,22) print(result) 测试模块 在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如： test.py def add(a,b): return a+b # 用来进行测试 ret = add(12,22) print('int test.py file,,,,12+22=%d'%ret) 如果此时，在其他py文件中引入了此文件的话，想想看，测试的那段代码是否也会执行呢！ main.py import test result = test.add(11,22) print(result) 运行现象： 至此，可发现test.py中的测试代码，应该是单独执行test.py文件时才应该执行的，不应该是其他的文件中引用而执行 为了解决这个问题，python在执行一个文件时有个变量__name__ 直接运行此文件 在其他文件中import此文件 总结： 可以根据__name__变量的结果能够判断出，是直接执行的python脚本还是被引入执行的，从而能够有选择性的执行测试代码 "},"primary/mian-xiang-dui-xiang-3/mo-kuai-zhong-de-all.html":{"url":"primary/mian-xiang-dui-xiang-3/mo-kuai-zhong-de-all.html","title":"模块中的__all__","keywords":"","body":"模块中的__all__ 1. 没有__all__ 2. 模块中有__all__ 总结 模块中的__all__ 1. 没有__all__ 2. 模块中有__all__ 总结 如果一个文件中有__all__变量，那么也就意味着这个变量中的元素，不会被from xxx import *时导入 "},"primary/mian-xiang-dui-xiang-3/pythonzhong-de-bao.html":{"url":"primary/mian-xiang-dui-xiang-3/pythonzhong-de-bao.html","title":"python中的包","keywords":"","body":"python中的包 引入包 1.1 有2个模块功能有些联系 1.2 所以将其放到同一个文件夹下 1.3 使用import 文件.模块 的方式导入 1.4 使用from 文件夹 import 模块 的方式导入 1.5 在msg文件夹下创建__init__.py文件 1.6 在__init__.py文件中写入 1.7 重新使用from 文件夹 import 模块 的方式导入 总结： __init__.py文件有什么用 __init__.py为空 __all__ (了解)可以在__init__.py文件中编写内容 扩展：嵌套的包 python中的包 引入包 1.1 有2个模块功能有些联系 1.2 所以将其放到同一个文件夹下 1.3 使用import 文件.模块 的方式导入 1.4 使用from 文件夹 import 模块 的方式导入 1.5 在msg文件夹下创建__init__.py文件 1.6 在__init__.py文件中写入 1.7 重新使用from 文件夹 import 模块 的方式导入 总结： 包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为__init__.py文件，那么这个文件夹就称之为包 有效避免模块名称冲突问题，让应用组织结构更加清晰 __init__.py文件有什么用 __init__.py控制着包的导入行为 __init__.py为空 仅仅是把这个包导入，不会导入包中的模块 __all__ 在__init__.py文件中，定义一个__all__变量，它控制着 from 包名 import *时导入的模块 (了解)可以在__init__.py文件中编写内容 可以在这个文件中编写语句，当导入时，这些语句就会被执行 __init__.py文件 扩展：嵌套的包 假定我们的包的例子有如下的目录结构： Phone/ __init__.py common_util.py Voicedta/ __init__.py Pots.py Isdn.py Fax/ __init__.py G3.py Mobile/ __init__.py Analog.py igital.py Pager/ __init__.py Numeric.py Phone 是最顶层的包，Voicedta 等是它的子包。 我们可以这样导入子包： import Phone.Mobile.Analog Phone.Mobile.Analog.dial() 你也可使用 from-import 实现不同需求的导入 第一种方法是只导入顶层的子包，然后使用属性/点操作符向下引用子包树： from Phone import Mobile Mobile.Analog.dial('555-1212') 此外，我们可以还引用更多的子包： from Phone.Mobile import Analog Analog.dial('555-1212') 事实上，你可以一直沿子包的树状结构导入： from Phone.Mobile.Analog import dial dial('555-1212') 在我们上边的目录结构中，我们可以发现很多的__init__.py文件。这些是初始化模块，from-import 语句导入子包时需要用到它。 如果没有用到，他们可以是空文件。 包同样支持 from-import all 语句： from package.module import * 然而，这样的语句会导入哪些文件取决于操作系统的文件系统。所以我们在__init__.py中加入__all__变量。该变量包含执行这样的语句时应该导入的模块的名字。它由一个模块名字符串列表组成.。 "},"primary/mian-xiang-dui-xiang-3/mo-kuai-fa-bu.html":{"url":"primary/mian-xiang-dui-xiang-3/mo-kuai-fa-bu.html","title":"模块发布","keywords":"","body":"模块发布 模块发布 模块发布 1.mymodule目录结构体如下： . ├── setup.py ├── suba │ ├── aa.py │ ├── bb.py │ └── __init__.py └── subb ├── cc.py ├── dd.py └── __init__.py 2.编辑setup.py文件 py_modules需指明所需包含的py文件 from distutils.core import setup setup(name=\"dongGe\", version=\"1.0\", description=\"dongGe's module\", author=\"dongGe\", py_modules=['suba.aa', 'suba.bb', 'subb.cc', 'subb.dd']) 3.构建模块 python setup.py build 构建后目录结构 . ├── build │ └── lib.linux-i686-2.7 │ ├── suba │ │ ├── aa.py │ │ ├── bb.py │ │ └── __init__.py │ └── subb │ ├── cc.py │ ├── dd.py │ └── __init__.py ├── setup.py ├── suba │ ├── aa.py │ ├── bb.py │ └── __init__.py └── subb ├── cc.py ├── dd.py └── __init__.py 4.生成发布压缩包 python setup.py sdist 打包后,生成最终发布压缩包dongGe-1.0.tar.gz , 目录结构 . ├── build │ └── lib.linux-i686-2.7 │ ├── suba │ │ ├── aa.py │ │ ├── bb.py │ │ └── __init__.py │ └── subb │ ├── cc.py │ ├── dd.py │ └── __init__.py ├── dist │ └── dongGe-1.0.tar.gz ├── MANIFEST ├── setup.py ├── suba │ ├── aa.py │ ├── bb.py │ └── __init__.py └── subb ├── cc.py ├── dd.py └── __init__.py "},"primary/mian-xiang-dui-xiang-3/mo-kuai-an-zhuang-3001-shi-yong.html":{"url":"primary/mian-xiang-dui-xiang-3/mo-kuai-an-zhuang-3001-shi-yong.html","title":"模块安装、使用","keywords":"","body":"模块安装、使用 安装的方式 模块的引入 模块安装、使用 安装的方式 找到模块的压缩包 解压 进入文件夹 执行命令 python setup.py install 注意： 如果在install的时候，执行目录安装，可以使用 python setup.py install --prefix=安装路径 模块的引入 在程序中，使用from import 即可完成对安装的模块使用 from 模块名 import 模块名或者* "},"primary/qiang-hua-lian-xi/gei-cheng-xu-chuan-can-shu.html":{"url":"primary/qiang-hua-lian-xi/gei-cheng-xu-chuan-can-shu.html","title":"给程序传参数","keywords":"","body":"给程序传参数 给程序传参数 import sys print(sys.argv) 运行结果: "},"primary/qiang-hua-lian-xi/lie-biao-tui-dao-shi.html":{"url":"primary/qiang-hua-lian-xi/lie-biao-tui-dao-shi.html","title":"列表推导式","keywords":"","body":"列表推导式 基本的方式 在循环的过程中使用if 2个for循环 3个for循环 练习 列表推导式 所谓的列表推导式，就是指的轻量级循环创建列表 基本的方式 在循环的过程中使用if 2个for循环 3个for循环 练习 生成一个[[1,2,3],[4,5,6]....]的列表最大值在100以内 请写出一段 Python 代码实现分组一个 list 里面的元素,比如 [1,2,3,...100]变成 [[1,2,3],[4,5,6]....] "},"primary/qiang-hua-lian-xi/setlisttuple.html":{"url":"primary/qiang-hua-lian-xi/setlisttuple.html","title":"set、list、tuple","keywords":"","body":"set、list、tuple set是集合类型 set、list、tuple之间可以相互转换 使用set，可以快速的完成对list中的元素去重复的功能 set、list、tuple set是集合类型 set、list、tuple之间可以相互转换 使用set，可以快速的完成对list中的元素去重复的功能 "},"primary/qiang-hua-lian-xi/si-kao-ti.html":{"url":"primary/qiang-hua-lian-xi/si-kao-ti.html","title":"思考题","keywords":"","body":" 在 Python 中,类和对象有什么区别?对象如何访问类的方法? 创建一个对象时做了什么? 请写出一段 Python 代码实现分组一个 list 里面的元素,比如 [1,2,3,...100]变成 [[1,2,3],[4,5,6]....] 请写出一段 Python 代码实现删除一个 list 里面的重复元素 设计实现遍历目录与子目录,抓取.pyc 文件 写出一个函数,给定参数 n,生成含有 n 个元素值为 1~n 的数 组,元素顺序随机,但值不重复 在不用其他变量的情况下，交换a、b变量的值 如何在一个 function 里设置一个全局变 请问如下代码会输出什么？ "},"primary/da-fei-ji/chuang-jian-jie-mian.html":{"url":"primary/da-fei-ji/chuang-jian-jie-mian.html","title":"创建界面","keywords":"","body":"搭建界面 搭建界面 #coding=utf-8 import pygame ''' 1. 搭建界面，主要完成窗口和背景图的显示 ''' if __name__ == \"__main__\": #1. 创建一个窗口，用来显示内容 screen = pygame.display.set_mode((480,890),0,32) #2. 创建一个和窗口大小的图片，用来充当背景 background = pygame.image.load(\"./feiji/background.png\").convert() #3. 把背景图片放到窗口中显示 while True: screen.blit(background,(0,0)) pygame.display.update() "},"primary/da-fei-ji/jian-ce-jian-pan.html":{"url":"primary/da-fei-ji/jian-ce-jian-pan.html","title":"检测键盘","keywords":"","body":"检测键盘 检测键盘 #coding=utf-8 import pygame from pygame.locals import * ''' 2. 用来检测事件，比如按键操作 ''' if __name__ == \"__main__\": #1. 创建一个窗口，用来显示内容 screen = pygame.display.set_mode((480,890),0,32) #2. 创建一个和窗口大小的图片，用来充当背景 background = pygame.image.load(\"./feiji/background.png\").convert() #3. 把背景图片放到窗口中显示 while True: #设定需要显示的背景图 screen.blit(background,(0,0)) #获取事件，比如按键等 for event in pygame.event.get(): #判断是否是点击了退出按钮 if event.type == QUIT: print(\"exit\") exit() #判断是否是按下了键 elif event.type == KEYDOWN: #检测按键是否是a或者left if event.key == K_a or event.key == K_LEFT: print('left') #检测按键是否是d或者right elif event.key == K_d or event.key == K_RIGHT: print('right') #检测按键是否是空格键 elif event.key == K_SPACE: print('space') #更新需要显示的内容 pygame.display.update() "},"primary/da-fei-ji/xian-shi-3001-kong-zhi-wan-ju-fei-673a-mian-xiang-guo-cheng.html":{"url":"primary/da-fei-ji/xian-shi-3001-kong-zhi-wan-ju-fei-673a-mian-xiang-guo-cheng.html","title":"显示、控制玩具飞机-面向过程","keywords":"","body":"显示、控制玩具飞机-面向过程 显示、控制玩具飞机-面向过程 #coding=utf-8 import pygame from pygame.locals import * ''' 3. 使用面向过程的方式来显示一个飞机，并控制其左右移动 ''' if __name__ == \"__main__\": #1. 创建一个窗口，用来显示内容 screen = pygame.display.set_mode((480,890),0,32) #2. 创建一个和窗口大小的图片，用来充当背景 background = pygame.image.load(\"./feiji/background.png\").convert() #测试，用来创建一个玩家飞机的图片 hero = pygame.image.load(\"./feiji/hero.gif\").convert() #用来保存飞机的x，y坐标 x=0 y=0 #3. 把背景图片放到窗口中显示 while True: screen.blit(background,(0,0)) #设定需要显示的飞机图片 screen.blit(hero,(x,y)) #判断是否是点击了退出按钮 for event in pygame.event.get(): # print(event.type) if event.type == QUIT: print(\"exit\") exit() elif event.type == KEYDOWN: if event.key == K_a or event.key == K_LEFT: print('left') #控制飞机让其向左移动 x-=5 elif event.key == K_d or event.key == K_RIGHT: print('right') #控制飞机让其向右移动 x+=5 elif event.key == K_SPACE: print('space') pygame.display.update() "},"primary/da-fei-ji/xian-shi-3001-kong-zhi-wan-ju-fei-673a-mian-xiang-dui-xiang.html":{"url":"primary/da-fei-ji/xian-shi-3001-kong-zhi-wan-ju-fei-673a-mian-xiang-dui-xiang.html","title":"显示、控制玩具飞机-面向对象","keywords":"","body":"显示、控制玩具飞机-面向对象 显示、控制玩具飞机-面向对象 #coding=utf-8 import pygame from pygame.locals import * ''' 4. 使用面向对象的方式显示飞机，以及控制其左右移动 练一下：接下来要做的任务： 1. 实现飞机在你想要的位置显示 2. 实现按键控制飞机移动 3. 实现按下空格键的时候，显示一颗子弹 ''' class HeroPlane(object): def __init__(self,screen): #设置飞机默认的位置 self.x = 230 self.y = 600 #设置要显示内容的窗口 self.screen = screen #用来保存英雄飞机需要的图片名字 self.imageName = \"./feiji/hero.gif\" #根据名字生成飞机图片 self.image = pygame.image.load(self.imageName).convert() #用来保存英雄飞机发射出的所有子弹 self.bullet = [] def display(self): self.screen.blit(self.image,(self.x,self.y)) def moveLeft(self): self.x -= 10 def moveRight(self): self.x += 10 def sheBullet(self): pass if __name__ == \"__main__\": #1. 创建一个窗口，用来显示内容 screen = pygame.display.set_mode((480,890),0,32) #2. 创建一个和窗口大小的图片，用来充当背景 background = pygame.image.load(\"./feiji/background.png\").convert() #3. 创建一个飞机对象 heroPlane = HeroPlane(screen) #3. 把背景图片放到窗口中显示 while True: screen.blit(background,(0,0)) heroPlane.display() #判断是否是点击了退出按钮 for event in pygame.event.get(): # print(event.type) if event.type == QUIT: print(\"exit\") exit() elif event.type == KEYDOWN: if event.key == K_a or event.key == K_LEFT: print('left') heroPlane.moveLeft() #控制飞机让其向左移动 elif event.key == K_d or event.key == K_RIGHT: print('right') heroPlane.moveRight() elif event.key == K_SPACE: print('space') pygame.display.update() "},"primary/da-fei-ji/wan-jia-fei-ji-fa-she-zi-dan.html":{"url":"primary/da-fei-ji/wan-jia-fei-ji-fa-she-zi-dan.html","title":"玩家飞机发射子弹","keywords":"","body":"玩家飞机发射子弹 玩家飞机发射子弹 #coding=utf-8 import pygame from pygame.locals import * ''' 实现玩家飞机发射子弹 接下来要做的任务： 1. 实现飞机在你想要的位置显示 2. 实现按键控制飞机移动 3. 实现按下空格键的时候，显示一颗子弹 ''' class HeroPlane(object): def __init__(self,screen): #设置飞机默认的位置 self.x = 230 self.y = 600 #设置要显示内容的窗口 self.screen = screen self.imageName = \"./feiji/hero.gif\" self.image = pygame.image.load(self.imageName).convert() #用来存储英雄飞机发射的所有子弹 self.bulletList = [] def display(self): self.screen.blit(self.image,(self.x,self.y)) for bullet in self.bulletList: bullet.display() bullet.move() #修改所有子弹的位置 # for bullet in self.bulletList: # bullet.y -= 2 def moveLeft(self): self.x -= 10 def moveRight(self): self.x += 10 def sheBullet(self): newBullet = Bullet(self.x,self.y,self.screen) self.bulletList.append(newBullet) class Bullet(object): def __init__(self,x,y,screen): self.x = x+40 self.y = y-20 self.screen = screen self.image = pygame.image.load(\"./feiji/bullet-3.gif\").convert() def move(self): self.y -= 2 def display(self): self.screen.blit(self.image,(self.x,self.y)) if __name__ == \"__main__\": #1. 创建一个窗口，用来显示内容 screen = pygame.display.set_mode((480,890),0,32) #2. 创建一个和窗口大小的图片，用来充当背景 background = pygame.image.load(\"./feiji/background.png\").convert() #3. 创建一个飞机对象 heroPlane = HeroPlane(screen) #3. 把背景图片放到窗口中显示 while True: screen.blit(background,(0,0)) heroPlane.display() #判断是否是点击了退出按钮 for event in pygame.event.get(): # print(event.type) if event.type == QUIT: print(\"exit\") exit() elif event.type == KEYDOWN: if event.key == K_a or event.key == K_LEFT: print('left') heroPlane.moveLeft() #控制飞机让其向左移动 elif event.key == K_d or event.key == K_RIGHT: print('right') heroPlane.moveRight() elif event.key == K_SPACE: print(\"space\") heroPlane.sheBullet() pygame.display.update() "},"primary/da-fei-ji/xian-shi-di-ji.html":{"url":"primary/da-fei-ji/xian-shi-di-ji.html","title":"显示敌机","keywords":"","body":"显示敌机显示敌机 #coding=utf-8 import pygame from pygame.locals import * ''' 显示敌人飞机 ''' class HeroPlane(object): def __init__(self,screen): #设置飞机默认的位置 self.x = 230 self.y = 600 #设置要显示内容的窗口 self.screen = screen self.imageName = \"./feiji/hero.gif\" self.image = pygame.image.load(self.imageName).convert() #用来存储英雄飞机发射的所有子弹 self.bulletList = [] def display(self): self.screen.blit(self.image,(self.x,self.y)) for bullet in self.bulletList: bullet.display() bullet.move() #修改所有子弹的位置 # for bullet in self.bulletList: # bullet.y -= 2 def moveLeft(self): self.x -= 10 def moveRight(self): self.x += 10 def sheBullet(self): newBullet = Bullet(self.x,self.y,self.screen) self.bulletList.append(newBullet) class Bullet(object): def __init__(self,x,y,screen): self.x = x+40 self.y = y-20 self.screen = screen self.image = pygame.image.load(\"./feiji/bullet-3.gif\").convert() def move(self): self.y -= 2 def display(self): self.screen.blit(self.image,(self.x,self.y)) class EnemyPlane(object): def __init__(self,screen): #设置飞机默认的位置 self.x = 0 self.y = 0 #设置要显示内容的窗口 self.screen = screen self.imageName = \"./feiji/enemy-1.gif\" self.image = pygame.image.load(self.imageName).convert() #用来存储敌人飞机发射的所有子弹 self.bulletList = [] def display(self): self.screen.blit(self.image,(self.x,self.y)) if __name__ == \"__main__\": #1. 创建一个窗口，用来显示内容 screen = pygame.display.set_mode((480,890),0,32) #2. 创建一个和窗口大小的图片，用来充当背景 background = pygame.image.load(\"./feiji/background.png\").convert() #3. 创建一个飞机对象 heroPlane = HeroPlane(screen) #4. 创建一个敌人飞机 enemyPlane = EnemyPlane(screen) #3. 把背景图片放到窗口中显示 while True: screen.blit(background,(0,0)) heroPlane.display() enemyPlane.display() #判断是否是点击了退出按钮 for event in pygame.event.get(): # print(event.type) if event.type == QUIT: print(\"exit\") exit() elif event.type == KEYDOWN: if event.key == K_a or event.key == K_LEFT: print('left') heroPlane.moveLeft() #控制飞机让其向左移动 elif event.key == K_d or event.key == K_RIGHT: print('right') heroPlane.moveRight() elif event.key == K_SPACE: print(\"space\") heroPlane.sheBullet() pygame.display.update() "},"primary/da-fei-ji/you-hua-dai-ma.html":{"url":"primary/da-fei-ji/you-hua-dai-ma.html","title":"优化代码","keywords":"","body":"优化代码优化代码 #coding=utf-8 import pygame from pygame.locals import * ''' 优化代码：优化发射出的子弹 ''' class HeroPlane(object): def __init__(self,screen): #设置飞机默认的位置 self.x = 230 self.y = 600 #设置要显示内容的窗口 self.screen = screen self.imageName = \"./feiji/hero.gif\" self.image = pygame.image.load(self.imageName).convert() #用来存储英雄飞机发射的所有子弹 self.bulletList = [] def display(self): #更新飞机的位置 self.screen.blit(self.image,(self.x,self.y)) #判断一下子弹的位置是否越界，如果是，那么就要删除这颗子弹 # #这种方法会漏掉很多需要删除的数据 # for i in self.bulletList: # if i.y "},"primary/da-fei-ji/rang-di-ji-yi-dong.html":{"url":"primary/da-fei-ji/rang-di-ji-yi-dong.html","title":"让敌机移动","keywords":"","body":"让敌机移动让敌机移动 #coding=utf-8 import time import random import pygame from pygame.locals import * class HeroPlane(object): def __init__(self,screen): #设置飞机默认的位置 self.x = 230 self.y = 600 #设置要显示内容的窗口 self.screen = screen self.imageName = \"./feiji/hero.gif\" self.image = pygame.image.load(self.imageName).convert() #用来存储英雄飞机发射的所有子弹 self.bulletList = [] def display(self): #更新飞机的位置 self.screen.blit(self.image,(self.x,self.y)) #判断一下子弹的位置是否越界，如果是，那么就要删除这颗子弹 # #这种方法会漏掉很多需要删除的数据 # for i in self.bulletList: # if i.y480-50: self.direction = \"left\" elif self.x "},"primary/da-fei-ji/di-ji-fa-she-zi-dan.html":{"url":"primary/da-fei-ji/di-ji-fa-she-zi-dan.html","title":"敌机发射子弹","keywords":"","body":"敌机发射子弹敌机发射子弹 #coding=utf-8 import time import random import pygame from pygame.locals import * class HeroPlane(object): def __init__(self,screen): #设置飞机默认的位置 self.x = 230 self.y = 600 #设置要显示内容的窗口 self.screen = screen self.imageName = \"./feiji/hero.gif\" self.image = pygame.image.load(self.imageName).convert() #用来存储英雄飞机发射的所有子弹 self.bulletList = [] def display(self): #更新飞机的位置 self.screen.blit(self.image,(self.x,self.y)) #判断一下子弹的位置是否越界，如果是，那么就要删除这颗子弹 # #这种方法会漏掉很多需要删除的数据 # for i in self.bulletList: # if i.y480-50: self.direction = \"left\" elif self.x890: return True else: return False if __name__ == \"__main__\": #1. 创建一个窗口，用来显示内容 screen = pygame.display.set_mode((480,890),0,32) #2. 创建一个和窗口大小的图片，用来充当背景 background = pygame.image.load(\"./feiji/background.png\").convert() #3. 创建一个飞机对象 heroPlane = HeroPlane(screen) #4. 创建一个敌人飞机 enemyPlane = EnemyPlane(screen) #3. 把背景图片放到窗口中显示 while True: screen.blit(background,(0,0)) heroPlane.display() enemyPlane.move() enemyPlane.sheBullet() enemyPlane.display() #判断是否是点击了退出按钮 for event in pygame.event.get(): # print(event.type) if event.type == QUIT: print(\"exit\") exit() elif event.type == KEYDOWN: if event.key == K_a or event.key == K_LEFT: print('left') heroPlane.moveLeft() #控制飞机让其向左移动 elif event.key == K_d or event.key == K_RIGHT: print('right') heroPlane.moveRight() elif event.key == K_SPACE: print(\"space\") heroPlane.sheBullet() #通过延时的方式，来降低这个while循环的循环速度，从而降低了cpu占用率 time.sleep(0.01) pygame.display.update() "},"primary/da-fei-ji/dai-ma-you-5316-chou-xiang-chu-ji-lei.html":{"url":"primary/da-fei-ji/dai-ma-you-5316-chou-xiang-chu-ji-lei.html","title":"代码优化-抽象出基类","keywords":"","body":"代码优化-抽象出基类代码优化-抽象出基类 #coding=utf-8 import time import random import pygame from pygame.locals import * class Base(object): def __init__(self,screen,name): self.name = name #设置要显示内容的窗口 self.screen = screen class Plane(Base): def __init__(self,screen,name): super().__init__(screen,name) self.image = pygame.image.load(self.imageName).convert() #用来存储英雄飞机发射的所有子弹 self.bulletList = [] def display(self): #更新飞机的位置 self.screen.blit(self.image,(self.x,self.y)) #判断一下子弹的位置是否越界，如果是，那么就要删除这颗子弹 # #这种方法会漏掉很多需要删除的数据 # for i in self.bulletList: # if i.y480-50: self.direction = \"left\" elif self.x890 or self.y "},"primary/zhi-shi-dian-shi-yi/yuan-lei.html":{"url":"primary/zhi-shi-dian-shi-yi/yuan-lei.html","title":"元类","keywords":"","body":"元类 元类 1. 类也是对象 在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立： > > > class ObjectCreator (object) : … pass … > > > my_object = ObjectCreator() > > > print my_object 但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。 下面的代码段： > > > class ObjectCreator (object) : … pass … 将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类对象ObjectCreator）拥有创建对象（实例对象）的能力。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作： 你可以将它赋值给一个变量 你可以拷贝它 你可以为它增加属性 你可以将它作为函数参数进行传递 下面是示例： > > > print ObjectCreator # 你可以打印一个类，因为它其实也是一个对象 > > > def echo(o): … print o … > > > echo(ObjectCreator) # 你可以将类做为参数传给函数 > > > print hasattr(ObjectCreator, 'new_attribute') Fasle > > > ObjectCreator.new_attribute = 'foo' # 你可以为类增加属性 > > > print hasattr(ObjectCreator, 'new_attribute') True > > > print ObjectCreator.new_attribute foo > > > ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量 > > > print ObjectCreatorMirror() 2. 动态地创建类 因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。 > > > def choose_class(name): … if name == 'foo': … class Foo(object): … pass … return Foo # 返回的是类，不是类的实例 … else: … class Bar(object): … pass … return Bar … > > > MyClass = choose_class('foo') > > > print MyClass # 函数返回的是类，不是类的实例 > > > print MyClass() # 你可以通过这个类创建类实例，也就是对象 但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。 还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样： > > > print type(1) #数值的类型 > > > print type(\"1\") #字符串的类型 > > > print type(ObjectCreator()) #实例对象的类型 > > > print type(ObjectCreator) #类的类型 仔细观察上面的运行结果，发现使用type对ObjectCreator查看类型是，答案为type， 是不是有些惊讶。。。看下面 3. 使用type创建类 type还有一种完全不同的功能，动态的创建类。 type可以接受一个类的描述作为参数，然后返回一个类。（要知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性） type可以像这样工作： type(类名, 由父类名称组成的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）) 比如下面的代码： In [ 2 ]: class Test : #定义了一个Test类 ...: pass ...: In [ 3 ]: Test() #创建了一个Test类的实例对象 Out[ 3 ]: 可以手动像这样创建： Test2 = type( \"Test2\" ,(),{}) #定了一个Test2类 In [ 5 ]: Test2() #创建了一个Test2类的实例对象 Out[ 5 ]: 我们使用\"Test2\"作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。即type函数中第1个实参，也可以叫做其他的名字，这个名字表示类的名字 In [23]: MyDogClass = type('MyDog', (), {}) In [24]: print MyDogClass 使用help来测试这2个类 In [10]: help(Test) #用help查看Test类 Help on class Test in module __main__: class Test(builtins.object) | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) In [8]: help(Test2) #用help查看Test2类 Help on class Test2 in module __main__: class Test2(builtins.object) | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) 4. 使用type创建带有属性的类 type 接受一个字典来为类定义属性，因此 > > > Foo = type( 'Foo' , (), { 'bar' : True }) 可以翻译为： > > > class Foo (object) : … bar = True 并且可以将Foo当成一个普通的类一样使用： > > > print Foo > > > print Foo.bar True > > > f = Foo() > > > print f > > > print f.bar True 当然，你可以向这个类继承，所以，如下的代码： > > > class FooChild (Foo) : … pass 就可以写成： > > > FooChild = type('FooChild', (Foo,),{}) > > > print FooChild > > > print FooChild.bar # bar属性是由Foo继承而来 True 注意： type的第2个参数，元组中是父类的名字，而不是字符串 添加的属性是类属性，并不是实例属性 5. 使用type创建带有方法的类 最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。 添加实例方法 In [ 46 ]: def echo_bar (self) : #定义了一个普通的函数 ...: print(self.bar) ...: In [ 47 ]: FooChild = type( 'FooChild' , (Foo,), { 'echo_bar' : echo_bar}) #让FooChild类中的echo_bar属性，指向了上面定义的函数 In [ 48 ]: hasattr(Foo, 'echo_bar' ) #判断Foo类中，是否有echo_bar这个属性 Out[ 48 ]: False In [ 49 ]: In [ 49 ]: hasattr(FooChild, 'echo_bar' ) #判断FooChild类中，是否有echo_bar这个属性 Out[ 49 ]: True In [ 50 ]: my_foo = FooChild() In [ 51 ]: my_foo.echo_bar() True 添加静态方法 In [ 36 ]: @staticmethod ...: def testStatic () : ...: print( \"static method ....\" ) ...: In [ 37 ]: Foochild = type( 'Foochild' , (Foo,), { \"echo_bar\" :echo_bar, \"testStatic\" : ...: testStatic}) In [ 38 ]: fooclid = Foochild() In [ 39 ]: fooclid.testStatic Out[ 39 ]: In [ 40 ]: fooclid.testStatic() static method .... In [ 41 ]: fooclid.echo_bar() True 添加类方法 In [ 42 ]: @classmethod ...: def testClass (cls) : ...: print(cls.bar) ...: In [ 43 ]: In [ 43 ]: Foochild = type( 'Foochild' , (Foo,), { \"echo_bar\" :echo_bar, \"testStatic\" : ...: testStatic, \"testClass\" :testClass}) In [ 44 ]: In [ 44 ]: fooclid = Foochild() In [ 45 ]: fooclid.testClass() True 你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。 6. 到底什么是元类（终于到主题了） 元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。 元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解为： MyClass = MetaClass() #使用元类创建出一个对象，这个对象称为“类” MyObject = MyClass() #使用“类”来创建出实例对象 你已经看到了type可以让你像这样做： MyClass = type( 'MyClass' , (), {}) 这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来，这个类就是type。 > > > age = 35 > > > age.__class__ > > > name = 'bob' > > > name.__class__ > > > def foo(): pass > > > foo.__class__ > > > class Bar(object): pass > > > b = Bar() > > > b.__class__ 现在，对于任何一个__class__的__class__属性又是什么呢？ > > > a.__class__.__class__ > > > age.__class__.__class__ > > > foo.__class__.__class__ > > > b.__class__.__class__ 因此，元类就是创建类这种对象的东西。type就是Python的内建元类，当然了，你也可以创建自己的元类。 7. __metaclass__属性 你可以在定义一个类的时候为其添加__metaclass__属性。 class Foo (object) : __metaclass__ = something… ...省略... 如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 : class Foo (Bar) : pass Python做了如下的操作： Foo中有__metaclass__这个属性吗？如果是，Python会通过__metaclass__创建一个名字为Foo的类(对象) 如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。 如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。 如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。 现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。 8. 自定义元类 元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。 假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。 幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类。所以，我们这里就先以一个简单的函数作为例子开始。 python2中 #-*- coding:utf-8 -*- def upper_attr (future_class_name, future_class_parents, future_class_attr) : #遍历属性字典，把不是__开头的属性名字变为大写 newAttr = {} for name,value in future_class_attr.items(): if not name.startswith( \"__\" ): newAttr[name.upper()] = value #调用type来创建一个类 return type(future_class_name, future_class_parents, newAttr) class Foo (object) : __metaclass__ = upper_attr #设置Foo类的元类为upper_attr bar = 'bip' print(hasattr(Foo, 'bar' )) print(hasattr(Foo, 'BAR' )) f = Foo() print(f.BAR) python3中 #-*- coding:utf-8 -*- def upper_attr (future_class_name, future_class_parents, future_class_attr) : #遍历属性字典，把不是__开头的属性名字变为大写 newAttr = {} for name,value in future_class_attr.items(): if not name.startswith( \"__\" ): newAttr[name.upper()] = value #调用type来创建一个类 return type(future_class_name, future_class_parents, newAttr) class Foo (object, metaclass=upper_attr) : bar = 'bip' print(hasattr(Foo, 'bar' )) print(hasattr(Foo, 'BAR' )) f = Foo() print(f.BAR) 现在让我们再做一次，这一次用一个真正的class来当做元类。 #coding=utf-8 class UpperAttrMetaClass (type) : # __new__ 是在__init__之前被调用的特殊方法 # __new__是用来创建对象并返回之的方法 # 而__init__只是用来将传入的参数初始化给对象 # 你很少用到__new__，除非你希望能够控制对象的创建 # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__ # 如果你希望的话，你也可以在__init__中做些事情 # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用 def __new__ (cls, future_class_name, future_class_parents, future_class_attr) : #遍历属性字典，把不是__开头的属性名字变为大写 newAttr = {} for name,value in future_class_attr.items(): if not name.startswith( \"__\" ): newAttr[name.upper()] = value # 方法1：通过'type'来做类对象的创建 # return type(future_class_name, future_class_parents, newAttr) # 方法2：复用type.__new__方法 # 这就是基本的OOP编程，没什么魔法 # return type.__new__(cls, future_class_name, future_class_parents, newAttr) # 方法3：使用super方法 return super(UpperAttrMetaClass, cls).__new__(cls, future_class_name, future_class_parents, newAttr) #python2的用法 class Foo (object) : __metaclass__ = UpperAttrMetaClass bar = 'bip' # python3的用法 # class Foo(object, metaclass = UpperAttrMetaClass): # bar = 'bip' print(hasattr(Foo, 'bar' )) # 输出: False print(hasattr(Foo, 'BAR' )) # 输出:True f = Foo() print(f.BAR) # 输出:'bip' 就是这样，除此之外，关于元类真的没有别的可说的了。但就元类本身而言，它们其实是很简单的： 拦截类的创建 修改类 返回修改之后的类 究竟为什么要使用元类？ 现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它： “元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” —— Python界的领袖 Tim Peters "},"primary/zhi-shi-dian-shi-yi/pythonshi-dong-tai-yu-yan.html":{"url":"primary/zhi-shi-dian-shi-yi/pythonshi-dong-tai-yu-yan.html","title":"python是动态语言","keywords":"","body":""},"primary/zhi-shi-dian-shi-yi/slots.html":{"url":"primary/zhi-shi-dian-shi-yi/slots.html","title":"__slots__","keywords":"","body":""},"primary/zhi-shi-dian-shi-yi/sheng-cheng-qi.html":{"url":"primary/zhi-shi-dian-shi-yi/sheng-cheng-qi.html","title":"生成器","keywords":"","body":""},"primary/zhi-shi-dian-shi-yi/die-dai-qi.html":{"url":"primary/zhi-shi-dian-shi-yi/die-dai-qi.html","title":"迭代器","keywords":"","body":""},"primary/zhi-shi-dian-shi-yi/bi-bao.html":{"url":"primary/zhi-shi-dian-shi-yi/bi-bao.html","title":"闭包","keywords":"","body":""},"primary/zhi-shi-dian-shi-yi/zhuang-shi-qi.html":{"url":"primary/zhi-shi-dian-shi-yi/zhuang-shi-qi.html","title":"装饰器","keywords":"","body":""},"primary/jin-cheng/duo-ren-wu-de-yin-ru.html":{"url":"primary/jin-cheng/duo-ren-wu-de-yin-ru.html","title":"多任务的引入","keywords":"","body":"现实生活中 有很多的场景中的事情是同时进行的，比如开车的时候 手和脚共同来驾驶汽车，再比如唱歌跳舞也是同时进行的； 如下视频是：迈克杰克逊的一段视频 http://v.youku.com/v_show/id_XMzE5NjEzNjA0.html?&sid=40117&from=y1.2-1.999.6 试想，如果把唱歌和跳舞这2件事情分开依次完成的话，估计就没有那么好的效果了（想一下场景：先唱歌，然后在跳舞，O(∩_∩)O哈哈~） 程序中 如下程序，来模拟“唱歌跳舞”这件事情 #coding=utf-8 from time import sleep def sing(): for i in range(3): print(\"正在唱歌...%d\"%i) sleep(1) def dance(): for i in range(3): print(\"正在跳舞...%d\"%i) sleep(1) if __name__ == '__main__': sing() #唱歌 dance() #跳舞 运行结果如下： !!!注意 很显然刚刚的程序并没有完成唱歌和跳舞同时进行的要求 如果想要实现“唱歌跳舞”同时进行，那么就需要一个新的方法，叫做： 多任务 "},"primary/jin-cheng/duo-ren-wu-de-gai-nian.html":{"url":"primary/jin-cheng/duo-ren-wu-de-gai-nian.html","title":"进程的创建-fork","keywords":"","body":"1. 进程 VS 程序 编写完毕的代码，在没有运行的时候，称之为程序 正在运行着的代码，就成为进程 进程，除了包含代码以外，还有需要运行的环境等，所以和程序是有区别的 2. fork( ) Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程： import os # 注意，fork函数，只在Unix/Linux/Mac上运行，windows不可以 pid = os.fork() if pid == 0: print('哈哈1') else: print('哈哈2') 运行结果： 哈哈2 哈哈1 说明： 程序执行到os.fork()时，操作系统会创建一个新的进程（子进程），然后复制父进程的所有信息到子进程中 然后父进程和子进程都会从fork()函数中得到一个返回值，在子进程中这个值一定是0，而父进程中是子进程的 id号 在Unix/Linux操作系统中，提供了一个fork()系统函数，它非常特殊。 普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 子进程永远返回0，而父进程返回子进程的ID。 这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 3. getpid()、getppid() import os rpid = os.fork() if rpid运行结果： 我是父进程（19360），我的子进程是（19361） 父子进程都可以执行这里的代码 我是子进程（19361），我的父进程是（19360） 父子进程都可以执行这里的代码 "},"primary/jin-cheng/duo-jin-cheng-xiu-gai-quan-ju-bian-liang.html":{"url":"primary/jin-cheng/duo-jin-cheng-xiu-gai-quan-ju-bian-liang.html","title":"多进程修改全局变量","keywords":"","body":"多进程修改全局变量 总结： 多进程修改全局变量 #coding=utf-8 import os import time num = 0 # 注意，fork函数，只在Unix/Linux/Mac上运行，windows不可以 pid = os.fork() if pid == 0: num+=1 print('哈哈1---num=%d'%num) else: time.sleep(1) num+=1 print('哈哈2---num=%d'%num) 运行结果: 哈哈1---num=1 哈哈2---num=1 总结： 多进程中，每个进程中所有数据（包括全局变量）都各有拥有一份，互不影响 "},"primary/jin-cheng/duo-ci-fork-wen-ti.html":{"url":"primary/jin-cheng/duo-ci-fork-wen-ti.html","title":"多次fork问题","keywords":"","body":"多次fork问题 父子进程的执行顺序 多次fork问题 如果在一个程序，有2次的fork函数调用，是否就会有3个进程呢？ #coding=utf-8 import os import time # 注意，fork函数，只在Unix/Linux/Mac上运行，windows不可以 pid = os.fork() if pid == 0: print('哈哈1') else: print('哈哈2') pid = os.fork() if pid == 0: print('哈哈3') else: print('哈哈4') time.sleep(1) 运行结果： 哈哈2 哈哈4 哈哈3 哈哈1 哈哈4 哈哈3 说明： 父子进程的执行顺序 父进程、子进程执行顺序没有规律，完全取决于操作系统的调度算法 "},"primary/jin-cheng/multiprocessing.html":{"url":"primary/jin-cheng/multiprocessing.html","title":"进程的创建-multiprocessing","keywords":"","body":"multiprocessing 说明 Process语法结构如下： multiprocessing 如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有fork调用，难道在Windows上无法用Python编写多进程的程序？ 由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。 multiprocessing模块提供了一个Process类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束： #coding=utf-8 from multiprocessing import Process import os # 子进程要执行的代码 def run_proc(name): print('子进程运行中，name= %s ,pid=%d...' % (name, os.getpid())) if __name__=='__main__': print('父进程 %d.' % os.getpid()) p = Process(target=run_proc, args=('test',)) print('子进程将要执行') p.start() p.join() print('子进程已结束') 运行结果: 说明 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。 join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 Process语法结构如下： Process([group [, target [, name [, args [, kwargs]]]]]) target：表示这个进程实例所调用对象； args：表示调用对象的位置参数元组； kwargs：表示调用对象的关键字参数字典； name：为当前进程实例的别名； group：大多数情况下用不到； Process类常用方法： is_alive()：判断进程实例是否还在执行； join([timeout])：是否等待进程实例执行结束，或等待多少秒； start()：启动进程实例（创建子进程）； run()：如果没有给定target参数，对这个对象调用start()方法时，就将执行对象中的run()方法； terminate()：不管任务是否完成，立即终止； Process类常用属性： name：当前进程实例别名，默认为Process-N，N为从1开始递增的整数； pid：当前进程实例的PID值； 实例1 from multiprocessing import Process import os from time import sleep # 子进程要执行的代码 def run_proc(name, age, **kwargs): for i in range(10): print('子进程运行中，name= %s,age=%d ,pid=%d...' % (name, age,os.getpid())) print(kwargs) sleep(0.5) if __name__=='__main__': print('父进程 %d.' % os.getpid()) p = Process(target=run_proc, args=('test',18), kwargs={\"m\":20}) print('子进程将要执行') p.start() sleep(1) p.terminate() p.join() print('子进程已结束') 运行结果: 父进程 21378. 子进程将要执行 子进程运行中，name= test,age=18 ,pid=21379... {'m': 20} 子进程运行中，name= test,age=18 ,pid=21379... {'m': 20} 子进程已结束 实例2 #coding=utf-8 from multiprocessing import Process import time import os #两个子进程将会调用的两个方法 def worker_1(interval): print(\"worker_1,父进程(%s),当前进程(%s)\"%(os.getppid(),os.getpid())) t_start = time.time() time.sleep(interval) #程序将会被挂起interval秒 t_end = time.time() print(\"worker_1,执行时间为'%0.2f'秒\"%(t_end - t_start)) def worker_2(interval): print(\"worker_2,父进程(%s),当前进程(%s)\"%(os.getppid(),os.getpid())) t_start = time.time() time.sleep(interval) t_end = time.time() print(\"worker_2,执行时间为'%0.2f'秒\"%(t_end - t_start)) #输出当前程序的ID print(\"进程ID：%s\"%os.getpid()) #创建两个进程对象，target指向这个进程对象要执行的对象名称， #args后面的元组中，是要传递给worker_1方法的参数， #因为worker_1方法就一个interval参数，这里传递一个整数2给它， #如果不指定name参数，默认的进程对象名称为Process-N，N为一个递增的整数 p1=Process(target=worker_1,args=(2,)) p2=Process(target=worker_2,name=\"dongGe\",args=(1,)) #使用\"进程对象名称.start()\"来创建并执行一个子进程， #这两个进程对象在start后，就会分别去执行worker_1和worker_2方法中的内容 p1.start() p2.start() #同时父进程仍然往下执行，如果p2进程还在执行，将会返回True print(\"p2.is_alive=%s\"%p2.is_alive()) #输出p1和p2进程的别名和pid print(\"p1.name=%s\"%p1.name) print(\"p1.pid=%s\"%p1.pid) print(\"p2.name=%s\"%p2.name) print(\"p2.pid=%s\"%p2.pid) #join括号中不携带参数，表示父进程在这个位置要等待p1进程执行完成后， #再继续执行下面的语句，一般用于进程间的数据同步，如果不写这一句， #下面的is_alive判断将会是True，在shell（cmd）里面调用这个程序时 #可以完整的看到这个过程，大家可以尝试着将下面的这条语句改成p1.join(1)， #因为p2需要2秒以上才可能执行完成，父进程等待1秒很可能不能让p1完全执行完成， #所以下面的print会输出True，即p1仍然在执行 p1.join() print(\"p1.is_alive=%s\"%p1.is_alive()) 执行结果: 进程ID：19866 p2.is_alive=True p1.name=Process-1 p1.pid=19867 p2.name=dongGe p2.pid=19868 worker_1,父进程(19866),当前进程(19867) worker_2,父进程(19866),当前进程(19868) worker_2,执行时间为'1.00'秒 worker_1,执行时间为'2.00'秒 p1.is_alive=False "},"primary/jin-cheng/jin-cheng-de-chuang-5efa-process-zi-lei.html":{"url":"primary/jin-cheng/jin-cheng-de-chuang-5efa-process-zi-lei.html","title":"进程的创建-Process子类","keywords":"","body":"进程的创建-Process子类 进程的创建-Process子类 创建新的进程还能够使用类的方式，可以自定义一个类，继承Process类，每次实例化这个类的时候，就等同于实例化一个进程对象，请看下面的实例： from multiprocessing import Process import time import os #继承Process类 class Process_Class(Process): #因为Process类本身也有__init__方法，这个子类相当于重写了这个方法， #但这样就会带来一个问题，我们并没有完全的初始化一个Process类，所以就不能使用从这个类继承的一些方法和属性， #最好的方法就是将继承类本身传递给Process.__init__方法，完成这些初始化操作 def __init__(self,interval): Process.__init__(self) self.interval = interval #重写了Process类的run()方法 def run(self): print(\"子进程(%s) 开始执行，父进程为（%s）\"%(os.getpid(),os.getppid())) t_start = time.time() time.sleep(self.interval) t_stop = time.time() print(\"(%s)执行结束，耗时%0.2f秒\"%(os.getpid(),t_stop-t_start)) if __name__==\"__main__\": t_start = time.time() print(\"当前程序进程(%s)\"%os.getpid()) p1 = Process_Class(2) #对一个不包含target属性的Process类执行start()方法，就会运行这个类中的run()方法，所以这里会执行p1.run() p1.start() p1.join() t_stop = time.time() print(\"(%s)执行结束，耗时%0.2f\"%(os.getpid(),t_stop-t_start)) "},"primary/jin-cheng/jin-cheng-chi-pool.html":{"url":"primary/jin-cheng/jin-cheng-chi-pool.html","title":"进程池Pool","keywords":"","body":"进程池Pool apply堵塞式 进程池Pool 当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。 初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行，请看下面的实例： from multiprocessing import Pool import os,time,random def worker(msg): t_start = time.time() print(\"%s开始执行,进程号为%d\"%(msg,os.getpid())) #random.random()随机生成0~1之间的浮点数 time.sleep(random.random()*2) t_stop = time.time() print(msg,\"执行完毕，耗时%0.2f\"%(t_stop-t_start)) po=Pool(3) #定义一个进程池，最大进程数3 for i in range(0,10): #Pool.apply_async(要调用的目标,(传递给目标的参数元祖,)) #每次循环将会用空闲出来的子进程去调用目标 po.apply_async(worker,(i,)) print(\"----start----\") po.close() #关闭进程池，关闭后po不再接收新的请求 po.join() #等待po中所有子进程执行完成，必须放在close语句之后 print(\"-----end-----\") 运行结果: ----start---- 0开始执行,进程号为21466 1开始执行,进程号为21468 2开始执行,进程号为21467 0 执行完毕，耗时1.01 3开始执行,进程号为21466 2 执行完毕，耗时1.24 4开始执行,进程号为21467 3 执行完毕，耗时0.56 5开始执行,进程号为21466 1 执行完毕，耗时1.68 6开始执行,进程号为21468 4 执行完毕，耗时0.67 7开始执行,进程号为21467 5 执行完毕，耗时0.83 8开始执行,进程号为21466 6 执行完毕，耗时0.75 9开始执行,进程号为21468 7 执行完毕，耗时1.03 8 执行完毕，耗时1.05 9 执行完毕，耗时1.69 -----end----- multiprocessing.Pool常用函数解析： apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表； apply(func[, args[, kwds]])：使用阻塞方式调用func close()：关闭Pool，使其不再接受新的任务； terminate()：不管任务是否完成，立即终止； join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用； apply堵塞式 from multiprocessing import Pool import os,time,random def worker(msg): t_start = time.time() print(\"%s开始执行,进程号为%d\"%(msg,os.getpid())) #random.random()随机生成0~1之间的浮点数 time.sleep(random.random()*2) t_stop = time.time() print(msg,\"执行完毕，耗时%0.2f\"%(t_stop-t_start)) po=Pool(3) #定义一个进程池，最大进程数3 for i in range(0,10): po.apply(worker,(i,)) print(\"----start----\") po.close() #关闭进程池，关闭后po不再接收新的请求 po.join() #等待po中所有子进程执行完成，必须放在close语句之后 print(\"-----end-----\") 运行结果: 0开始执行,进程号为21532 0 执行完毕，耗时1.91 1开始执行,进程号为21534 1 执行完毕，耗时1.72 2开始执行,进程号为21533 2 执行完毕，耗时0.50 3开始执行,进程号为21532 3 执行完毕，耗时1.27 4开始执行,进程号为21534 4 执行完毕，耗时1.05 5开始执行,进程号为21533 5 执行完毕，耗时1.60 6开始执行,进程号为21532 6 执行完毕，耗时0.25 7开始执行,进程号为21534 7 执行完毕，耗时0.63 8开始执行,进程号为21533 8 执行完毕，耗时1.21 9开始执行,进程号为21532 9 执行完毕，耗时0.60 ----start---- -----end----- "},"primary/jin-cheng/jin-cheng-jian-tong-4fe1-queue.html":{"url":"primary/jin-cheng/jin-cheng-jian-tong-4fe1-queue.html","title":"进程间通信-Queue","keywords":"","body":"进程间通信-Queue 1. Queue的使用 2. Queue实例 3. 进程池中的Queue 进程间通信-Queue Process之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。 1. Queue的使用 可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序，首先用一个小实例来演示一下Queue的工作原理： #coding=utf-8 from multiprocessing import Queue q=Queue(3) #初始化一个Queue对象，最多可接收三条put消息 q.put(\"消息1\") q.put(\"消息2\") print(q.full()) #False q.put(\"消息3\") print(q.full()) #True #因为消息列队已满下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常 try: q.put(\"消息4\",True,2) except: print(\"消息列队已满，现有消息数量:%s\"%q.qsize()) try: q.put_nowait(\"消息4\") except: print(\"消息列队已满，现有消息数量:%s\"%q.qsize()) #推荐的方式，先判断消息列队是否已满，再写入 if not q.full(): q.put_nowait(\"消息4\") #读取消息时，先判断消息列队是否为空，再读取 if not q.empty(): for i in range(q.qsize()): print(q.get_nowait()) 运行结果: False True 消息列队已满，现有消息数量:3 消息列队已满，现有消息数量:3 消息1 消息2 消息3 说明 初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）； Queue.qsize()：返回当前队列包含的消息数量； Queue.empty()：如果队列为空，返回True，反之False ； Queue.full()：如果队列满了，返回True,反之False； Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出\"Queue.Empty\"异常； 2）如果block值为False，消息列队如果为空，则会立刻抛出\"Queue.Empty\"异常； Queue.get_nowait()：相当Queue.get(False)； Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出\"Queue.Full\"异常； 2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出\"Queue.Full\"异常； Queue.put_nowait(item)：相当Queue.put(item, False)； 2. Queue实例 我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： from multiprocessing import Process, Queue import os, time, random # 写数据进程执行的代码: def write(q): for value in ['A', 'B', 'C']: print('Put %s to queue...' % value) q.put(value) time.sleep(random.random()) # 读数据进程执行的代码: def read(q): while True: if not q.empty(): value = q.get(True) print('Get %s from queue.' % value) time.sleep(random.random()) else: break if __name__ == '__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 等待pw结束: pw.join() # 启动子进程pr，读取: pr.start() pr.join() # pr进程里是死循环，无法等待其结束，只能强行终止: print('') print('所有数据都写入并且读完') 运行结果： Put A to queue... Put B to queue... Put C to queue... Get A from queue. Get B from queue. Get C from queue. 所有数据都写入并且读完 3. 进程池中的Queue 如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息： RuntimeError: Queue objects should only be shared between processes through inheritance. 下面的实例演示了进程池中的进程如何通信： #修改import中的Queue为Manager from multiprocessing import Manager,Pool import os,time,random def reader(q): print(\"reader启动(%s),父进程为(%s)\"%(os.getpid(),os.getppid())) for i in range(q.qsize()): print(\"reader从Queue获取到消息：%s\"%q.get(True)) def writer(q): print(\"writer启动(%s),父进程为(%s)\"%(os.getpid(),os.getppid())) for i in \"dongGe\": q.put(i) if __name__==\"__main__\": print(\"(%s) start\"%os.getpid()) q=Manager().Queue() #使用Manager中的Queue来初始化 po=Pool() #使用阻塞模式创建进程，这样就不需要在reader中使用死循环了，可以让writer完全执行完成后，再用reader去读取 po.apply(writer,(q,)) po.apply(reader,(q,)) po.close() po.join() print(\"(%s) End\"%os.getpid()) 运行结果: (21156) start writer启动(21162),父进程为(21156) reader启动(21162),父进程为(21156) reader从Queue获取到消息：d reader从Queue获取到消息：o reader从Queue获取到消息：n reader从Queue获取到消息：g reader从Queue获取到消息：G reader从Queue获取到消息：e (21156) End "},"primary/xian-cheng/duo-xian-7a0b-threading.html":{"url":"primary/xian-cheng/duo-xian-7a0b-threading.html","title":"多线程-threading","keywords":"","body":"多线程-threading 1. 使用threading模块 说明 2. 主线程会等待所有的子线程结束后才结束 3. 查看线程数量 多线程-threading python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用 1. 使用threading模块 单线程执行 #coding=utf-8 import time def saySorry(): print(\"亲爱的，我错了，我能吃饭了吗？\") time.sleep(1) if __name__ == \"__main__\": for i in range(5): saySorry() 运行结果： 亲爱的，我错了，我能吃饭了吗？ 亲爱的，我错了，我能吃饭了吗？ 亲爱的，我错了，我能吃饭了吗？ 亲爱的，我错了，我能吃饭了吗？ 亲爱的，我错了，我能吃饭了吗？ 多线程执行 #coding=utf-8 import threading import time def saySorry(): print(\"亲爱的，我错了，我能吃饭了吗？\") time.sleep(1) if __name__ == \"__main__\": for i in range(5): t = threading.Thread(target=saySorry) t.start() #启动线程，即让线程开始执行 运行结果： 亲爱的，我错了，我能吃饭了吗？ 亲爱的，我错了，我能吃饭了吗？ 亲爱的，我错了，我能吃饭了吗？ 亲爱的，我错了，我能吃饭了吗？ 亲爱的，我错了，我能吃饭了吗？ 说明 可以明显看出使用了多线程并发的操作，花费时间要短很多 创建好的线程，需要调用start()方法来启动 2. 主线程会等待所有的子线程结束后才结束 #coding=utf-8 import threading from time import sleep,ctime def sing(): for i in range(3): print(\"正在唱歌...%d\"%i) sleep(1) def dance(): for i in range(3): print(\"正在跳舞...%d\"%i) sleep(1) if __name__ == '__main__': print('---开始---:') t1 = threading.Thread(target=sing) t2 = threading.Thread(target=dance) t1.start() t2.start() #sleep(5) # 屏蔽此行代码，试试看，程序是否会立马结束？ print('---结束---:') 运行结果 ---开始---: 正在唱歌...0 正在跳舞...0 ---结束---: 正在唱歌...1 正在跳舞...1 正在跳舞...2 正在唱歌...2 3. 查看线程数量 #coding = utf - 8 import threading from time import sleep, ctime def sing(): for i in range(3): print(\"正在唱歌...%d\" % i) sleep(1) def dance(): for i in range(3): print(\"正在跳舞...%d\" % i) sleep(1) if __name__ == '__main__': print('---开始---:') t1 = threading.Thread(target=sing) t2 = threading.Thread(target=dance) t1.start() t2.start() while True: length = len(threading.enumerate()) print('当前运行的线程数为：%d' % length) if length 运行结果 ---开始---: 正在唱歌...0 正在唱歌...1 正在唱歌...2 正在跳舞...0 正在跳舞...1 正在跳舞...2 当前运行的线程数为：1 "},"primary/xian-cheng/threadingzhu-yi-dian.html":{"url":"primary/xian-cheng/threadingzhu-yi-dian.html","title":"threading注意点","keywords":"","body":"threading注意点 1. 线程执行代码的封装 说明 2. 线程的执行顺序 说明 3. 总结 threading注意点 1. 线程执行代码的封装 通过上一小节，能够看出，通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承threading.Thread就可以了，然后重写run方法 示例如下： #coding=utf-8 import threading import time class MyThread(threading.Thread): def run(self): for i in range(3): time.sleep(1) msg = \"I'm \"+self.name+' @ '+str(i) #name属性中保存的是当前线程的名字 print(msg) if __name__ == '__main__': t = MyThread() t.start() 运行结果 I'm Thread-1 @ 0 I'm Thread-1 @ 1 I'm Thread-1 @ 2 说明 python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。 2. 线程的执行顺序 #coding=utf-8 import threading import time class MyThread(threading.Thread): def run(self): for i in range(3): time.sleep(1) msg = \"I'm \"+self.name+' @ '+str(i) print(msg) def test(): for i in range(5): t = MyThread() t.start() if __name__ == '__main__': test() 执行结果：(运行的结果可能不一样，但是大体是一致的) I'm Thread-1 @ 0 I'm Thread-2 @ 0 I'm Thread-5 @ 0 I'm Thread-3 @ 0 I'm Thread-4 @ 0 I'm Thread-3 @ 1 I'm Thread-4 @ 1 I'm Thread-5 @ 1 I'm Thread-1 @ 1 I'm Thread-2 @ 1 I'm Thread-4 @ 2 I'm Thread-5 @ 2 I'm Thread-2 @ 2 I'm Thread-1 @ 2 I'm Thread-3 @ 2 说明 从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。 3. 总结 每个线程一定会有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。 当线程的run()方法结束时该线程完成。 无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。 线程的几种状态 "},"primary/xian-cheng/duo-xian-7a0b-gong-xiang-quan-ju-bian-liang.html":{"url":"primary/xian-cheng/duo-xian-7a0b-gong-xiang-quan-ju-bian-liang.html","title":"多线程-共享全局变量","keywords":"","body":"多线程-共享全局变量 列表当做实参传递到线程中 总结： 多线程-共享全局变量 from threading import Thread import time g_num = 100 def work1(): global g_num for i in range(3): g_num += 1 print(\"----in work1, g_num is %d---\"%g_num) def work2(): global g_num print(\"----in work2, g_num is %d---\"%g_num) print(\"---线程创建之前g_num is %d---\"%g_num) t1 = Thread(target=work1) t1.start() #延时一会，保证t1线程中的事情做完 time.sleep(1) t2 = Thread(target=work2) t2.start() 运行结果: ---线程创建之前g_num is 100--- ----in work1, g_num is 103--- ----in work2, g_num is 103--- 列表当做实参传递到线程中 from threading import Thread import time def work1(nums): nums.append(44) print(\"----in work1---\",nums) def work2(nums): #延时一会，保证t1线程中的事情做完 time.sleep(1) print(\"----in work2---\",nums) g_nums = [11,22,33] t1 = Thread(target=work1, args=(g_nums,)) t1.start() t2 = Thread(target=work2, args=(g_nums,)) t2.start() 运行结果: ----in work1--- [11, 22, 33, 44] ----in work2--- [11, 22, 33, 44] 总结： 在一个进程内的所有线程共享全局变量，能够在不适用其他方式的前提下完成多线程之间的数据共享（这点要比多进程要好） 缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全） "},"primary/xian-cheng/jin-cheng-vs-xian-cheng.html":{"url":"primary/xian-cheng/jin-cheng-vs-xian-cheng.html","title":"进程VS线程","keywords":"","body":"进程VS线程 功能 定义的不同 区别 优缺点 进程VS线程 功能 进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ 线程，能够完成多任务，比如 一个QQ中的多个聊天窗口 定义的不同 进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 区别 一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 线线程不能够独立执行，必须依存在进程中 优缺点 线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。 "},"primary/xian-cheng/tong-bu-de-gai-nian.html":{"url":"primary/xian-cheng/tong-bu-de-gai-nian.html","title":"同步的概念","keywords":"","body":"同步的概念 1. 多线程开发可能遇到的问题 2. 什么是同步 3. 解决问题的思路 同步的概念 1. 多线程开发可能遇到的问题 假设两个线程t1和t2都要对num=0进行增1运算，t1和t2都各对num修改10次，num的最终的结果应该为20。 但是由于是多线程访问，有可能出现下面情况： 在num=0时，t1取得num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得num=0。然后t2对得到的值进行加1并赋给num，使得num=1。然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给num。这样，明明t1和t2都完成了1次加1工作，但结果仍然是num=1。 from threading import Thread import time g_num = 0 def test1(): global g_num for i in range(1000000): g_num += 1 print(\"---test1---g_num=%d\"%g_num) def test2(): global g_num for i in range(1000000): g_num += 1 print(\"---test2---g_num=%d\"%g_num) p1 = Thread(target=test1) p1.start() # time.sleep(3) #取消屏蔽之后 再次运行程序，结果会不一样，，，为啥呢？ p2 = Thread(target=test2) p2.start() print(\"---g_num=%d---\"%g_num) 运行结果(可能不一样，但是结果往往不是2000000)： ---g_num=284672--- ---test1---g_num=1166544 ---test2---g_num=1406832 取消屏蔽之后，再次运行结果如下： ---test1---g_num=1000000 ---g_num=1041802--- ---test2---g_num=2000000 问题产生的原因就是没有控制多个线程对同一资源的访问，对数据造成破坏，使得线程运行的结果不可预期。这种现象称为“线程不安全”。 2. 什么是同步 同步就是协同步调，按预定的先后次序进行运行。如:你说完，我再说。 \"同\"字从字面上容易理解为一起动作 其实不是，\"同\"字应是指协同、协助、互相配合。 如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B依言执行，再将结果给A;A再继续操作。 3. 解决问题的思路 对于本小节提出的那个计算错误的问题，可以通过线程同步来进行解决 思路，如下: 系统调用t1，然后获取到num的值为0，此时上一把锁，即不允许其他现在操作num 对num的值进行+1 解锁，此时num的值为1，其他的线程就可以使用num了，而且是num的值不是0而是1 同理其他线程在对num进行修改时，都要先上锁，处理完后再解锁，在上锁的整个过程中不允许其他线程访问，就保证了数据的正确性 "},"primary/xian-cheng/hu-chi-suo.html":{"url":"primary/xian-cheng/hu-chi-suo.html","title":"互斥锁","keywords":"","body":"互斥锁 上锁解锁过程 总结 互斥锁 当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制 线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。 互斥锁为资源引入一个状态：锁定/非锁定。 某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。 threading模块中定义了Lock类，可以方便的处理锁定： #创建锁 mutex = threading.Lock() #锁定 mutex.acquire([blocking]) #释放 mutex.release() 其中，锁定方法acquire可以有一个blocking参数。 如果设定blocking为True，则当前线程会堵塞，直到获取到这个锁为止（如果没有指定，那么默认为True） 如果设定blocking为False，则当前线程不会堵塞 使用互斥锁实现上面的例子的代码如下： from threading import Thread, Lock import time g_num = 0 def test1(): global g_num for i in range(1000000): #True表示堵塞 即如果这个锁在上锁之前已经被上锁了，那么这个线程会在这里一直等待到解锁为止 #False表示非堵塞，即不管本次调用能够成功上锁，都不会卡在这,而是继续执行下面的代码 mutexFlag = mutex.acquire(True) if mutexFlag: g_num += 1 mutex.release() print(\"---test1---g_num=%d\"%g_num) def test2(): global g_num for i in range(1000000): mutexFlag = mutex.acquire(True) #True表示堵塞 if mutexFlag: g_num += 1 mutex.release() print(\"---test2---g_num=%d\"%g_num) #创建一个互斥锁 #这个所默认是未上锁的状态 mutex = Lock() p1 = Thread(target=test1) p1.start() p2 = Thread(target=test2) p2.start() print(\"---g_num=%d---\"%g_num) 运行结果： ---g_num=61866--- ---test1---g_num=1861180 ---test2---g_num=2000000 可以看到，加入互斥锁后，运行结果与预期相符。 上锁解锁过程 当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。 每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。 线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。 总结 锁的好处： 确保了某段关键代码只能由一个线程从头到尾完整地执行 锁的坏处： 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了 由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁 "},"primary/xian-cheng/duo-xian-7a0b-fei-gong-xiang-shu-ju.html":{"url":"primary/xian-cheng/duo-xian-7a0b-fei-gong-xiang-shu-ju.html","title":"多线程-非共享数据","keywords":"","body":"多线程-非共享数据 1. 非全局变量是否要加锁呢？ 小总结 多线程-非共享数据 对于全局变量，在多线程中要格外小心，否则容易造成数据错乱的情况发生 1. 非全局变量是否要加锁呢？ #coding=utf-8 import threading import time class MyThread(threading.Thread): # 重写 构造方法 def __init__(self,num,sleepTime): threading.Thread.__init__(self) self.num = num self.sleepTime = sleepTime def run(self): self.num += 1 time.sleep(self.sleepTime) print('线程(%s),num=%d'%(self.name, self.num)) if __name__ == '__main__': mutex = threading.Lock() t1 = MyThread(100,5) t1.start() t2 = MyThread(200,1) t2.start() 运行结果: 线程(Thread-2),num=201 线程(Thread-1),num=101 import threading from time import sleep def test(sleepTime): num=1 sleep(sleepTime) num+=1 print('---(%s)--num=%d'%(threading.current_thread(), num)) t1 = threading.Thread(target = test,args=(5,)) t2 = threading.Thread(target = test,args=(1,)) t1.start() t2.start() 运行结果 ---()--num=2 ---()--num=2 小总结 在多线程开发中，全局变量是多个线程都共享的数据，而局部变量等是各自线程的，是非共享的 "},"primary/xian-cheng/si-suo.html":{"url":"primary/xian-cheng/si-suo.html","title":"死锁","keywords":"","body":"死锁 1. 死锁 2. 说明 3. 避免死锁 附录-银行家算法 死锁 现实社会中，男女双方都在等待对方先道歉 如果双方都这样固执的等待对方先开口，弄不好，就分搜了 1. 死锁 在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。 尽管死锁很少发生，但一旦发生就会造成应用的停止响应。下面看一个死锁的例子 #coding=utf-8 import threading import time class MyThread1(threading.Thread): def run(self): if mutexA.acquire(): print(self.name+'----do1---up----') time.sleep(1) if mutexB.acquire(): print(self.name+'----do1---down----') mutexB.release() mutexA.release() class MyThread2(threading.Thread): def run(self): if mutexB.acquire(): print(self.name+'----do2---up----') time.sleep(1) if mutexA.acquire(): print(self.name+'----do2---down----') mutexA.release() mutexB.release() mutexA = threading.Lock() mutexB = threading.Lock() if __name__ == '__main__': t1 = MyThread1() t2 = MyThread2() t1.start() t2.start() 运行结果： Thread-1----do1---up---- Thread-2----do2---up---- | 此时已经进入到了死锁状态，可以使用ctrl-z退出 2. 说明 3. 避免死锁 程序设计时要尽量避免（银行家算法） 添加超时时间等 附录-银行家算法 [背景知识] 一个银行家如何将一定数目的资金安全地借给若干个客户，使这些客户既能借到钱完成要干的事，同时银行家又能收回全部资金而不至于破产，这就是银行家问题。这个问题同操作系统中资源分配问题十分相似：银行家就像一个操作系统，客户就像运行的进程，银行家的资金就是系统的资源。 [问题的描述] 一个银行家拥有一定数量的资金，有若干个客户要贷款。每个客户须在一开始就声明他所需贷款的总额。若该客户贷款总额不超过银行家的资金总数，银行家可以接收客户的要求。客户贷款是以每次一个资金单位（如1万RMB等）的方式进行的，客户在借满所需的全部单位款额之前可能会等待，但银行家须保证这种等待是有限的，可完成的。 例如：有三个客户C1，C2，C3，向银行家借款，该银行家的资金总额为10个资金单位，其中C1客户要借9各资金单位，C2客户要借3个资金单位，C3客户要借8个资金单位，总计20个资金单位。某一时刻的状态如图所示。 对于a图的状态，按照安全序列的要求，我们选的第一个客户应满足该客户所需的贷款小于等于银行家当前所剩余的钱款，可以看出只有C2客户能被满足：C2客户需1个资金单位，小银行家手中的2个资金单位，于是银行家把1个资金单位借给C2客户，使之完成工作并归还所借的3个资金单位的钱，进入b图。同理，银行家把4个资金单位借给C3客户，使其完成工作，在c图中，只剩一个客户C1，它需7个资金单位，这时银行家有8个资金单位，所以C1也能顺利借到钱并完成工作。最后（见图d）银行家收回全部10个资金单位，保证不赔本。那麽客户序列{C1，C2，C3}就是个安全序列，按照这个序列贷款，银行家才是安全的。否则的话，若在图b状态时，银行家把手中的4个资金单位借给了C1，则出现不安全状态：这时C1，C3均不能完成工作，而银行家手中又没有钱了，系统陷入僵持局面，银行家也不能收回投资。 综上所述，银行家算法是从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部贷款，再进而检查下一个能完成工作的客户，......。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。 "},"primary/xian-cheng/tong-bu-ying-yong.html":{"url":"primary/xian-cheng/tong-bu-ying-yong.html","title":"同步应用","keywords":"","body":"同步应用 多个线程有序执行 同步应用 多个线程有序执行 from threading import Thread,Lock from time import sleep class Task1(Thread): def run(self): while True: if lock1.acquire(): print(\"------Task 1 -----\") sleep(0.5) lock2.release() class Task2(Thread): def run(self): while True: if lock2.acquire(): print(\"------Task 2 -----\") sleep(0.5) lock3.release() class Task3(Thread): def run(self): while True: if lock3.acquire(): print(\"------Task 3 -----\") sleep(0.5) lock1.release() #使用Lock创建出的锁默认没有“锁上” lock1 = Lock() #创建另外一把锁，并且“锁上” lock2 = Lock() lock2.acquire() #创建另外一把锁，并且“锁上” lock3 = Lock() lock3.acquire() t1 = Task1() t2 = Task2() t3 = Task3() t1.start() t2.start() t3.start() 运行结果: ------Task 1 ----- ------Task 2 ----- ------Task 3 ----- ------Task 1 ----- ------Task 2 ----- ------Task 3 ----- ------Task 1 ----- ------Task 2 ----- ------Task 3 ----- ------Task 1 ----- ------Task 2 ----- ------Task 3 ----- ------Task 1 ----- ------Task 2 ----- ------Task 3 ----- ...省略... 总结 可以使用互斥锁完成多个任务，有序的进程工作，这就是线程的同步 "},"primary/xian-cheng/sheng-chan-zhe-yu-xiao-fei-zhe-mo-shi.html":{"url":"primary/xian-cheng/sheng-chan-zhe-yu-xiao-fei-zhe-mo-shi.html","title":"生产者与消费者模式","keywords":"","body":"生产者与消费者模式 1. 队列 2. 栈 3. Queue的说明 4. 生产者消费者模式的说明 生产者与消费者模式 1. 队列 先进先出 2. 栈 先进后出 Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么就做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。 用FIFO队列实现上述生产者与消费者问题的代码如下： #encoding=utf-8 import threading import time #python2中 from Queue import Queue #python3中 # from queue import Queue class Producer(threading.Thread): def run(self): global queue count = 0 while True: if queue.qsize() 100: for i in range(3): msg = self.name + '消费了 '+queue.get() print(msg) time.sleep(1) if __name__ == '__main__': queue = Queue() for i in range(500): queue.put('初始产品'+str(i)) for i in range(2): p = Producer() p.start() for i in range(5): c = Consumer() c.start() 3. Queue的说明 对于Queue，在多线程通信之间扮演重要的角色 添加数据到队列中，使用put()方法 从队列中取数据，使用get()方法 判断队列中是否还有数据，使用qsize()方法 4. 生产者消费者模式的说明 为什么要使用生产者和消费者模式 在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。 什么是生产者消费者模式 生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会找一个第三者出来进行解耦， "},"primary/xian-cheng/threadlocal.html":{"url":"primary/xian-cheng/threadlocal.html","title":"ThreadLocal","keywords":"","body":"ThreadLocal 1. 使用函数传参的方法 2. 使用全局字典的方法 3. 使用ThreadLocal的方法 说明 4. 小结 ThreadLocal 在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。 1. 使用函数传参的方法 但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦： def process_student(name): std = Student(name) # std是局部变量，但是每个函数都要用它，因此必须传进去： do_task_1(std) do_task_2(std) def do_task_1(std): do_subtask_1(std) do_subtask_2(std) def do_task_2(std): do_subtask_2(std) do_subtask_2(std) 每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的Student对象，不能共享。 2. 使用全局字典的方法 如果用一个全局dict存放所有的Student对象，然后以thread自身作为key获得线程对应的Student对象如何？ global_dict = {} def std_thread(name): std = Student(name) # 把std放到全局变量global_dict中： global_dict[threading.current_thread()] = std do_task_1() do_task_2() def do_task_1(): # 不传入std，而是根据当前线程查找： std = global_dict[threading.current_thread()] ... def do_task_2(): # 任何函数都可以查找出当前线程的std变量： std = global_dict[threading.current_thread()] ... 这种方式理论上是可行的，它最大的优点是消除了std对象在每层函数中的传递问题，但是，每个函数获取std的代码有点low。 有没有更简单的方式？ 3. 使用ThreadLocal的方法 ThreadLocal应运而生，不用查找dict，ThreadLocal帮你自动做这件事： import threading # 创建全局ThreadLocal对象: local_school = threading.local() def process_student(): # 获取当前线程关联的student: std = local_school.student print('Hello, %s (in %s)' % (std, threading.current_thread().name)) def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student() t1 = threading.Thread(target= process_thread, args=('dongGe',), name='Thread-A') t2 = threading.Thread(target= process_thread, args=('老王',), name='Thread-B') t1.start() t2.start() t1.join() t2.join() 执行结果： Hello, dongGe (in Thread-A) Hello, 老王 (in Thread-B) 说明 全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。 可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。 ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。 4. 小结 一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题 "},"primary/xian-cheng/yi-bu.html":{"url":"primary/xian-cheng/yi-bu.html","title":"异步","keywords":"","body":"异步 异步 同步调用就是你 喊 你朋友吃饭 ，你朋友在忙 ，你就一直在那等，等你朋友忙完了 ，你们一起去 异步调用就是你 喊 你朋友吃饭 ，你朋友说知道了 ，待会忙完去找你 ，你就去做别的了。 from multiprocessing import Pool import time import os def test(): print(\"---进程池中的进程---pid=%d,ppid=%d--\"%(os.getpid(),os.getppid())) for i in range(3): print(\"----%d---\"%i) time.sleep(1) return \"hahah\" def test2(args): print(\"---callback func--pid=%d\"%os.getpid()) print(\"---callback func--args=%s\"%args) pool = Pool(3) pool.apply_async(func=test,callback=test2) time.sleep(5) print(\"----主进程-pid=%d----\"%os.getpid()) 运行结果： ---进程池中的进程---pid=9401,ppid=9400-- ----0--- ----1--- ----2--- ---callback func--pid=9400 ---callback func--args=hahah ----主进程-pid=9400---- "},"primary/zhi-shi-dian-shi-yi/importdao-ru-mo-kuai.html":{"url":"primary/zhi-shi-dian-shi-yi/importdao-ru-mo-kuai.html","title":"import导入模块","keywords":"","body":"import导入模块 import导入模块 1. import 搜索路径 import sys sys.path 路径搜索 从上面列出的目录里依次查找要导入的模块文件 ' ' 表示当前路径 程序执行时导入模块路径 sys.path.append('/home/itcast/xxx') sys.path.insert(0, '/home/itcast/xxx') #可以确保先搜索这个路径 In [37]: sys.path.insert(0,\"/home/python/xxxx\") In [38]: sys.path Out[38]: ['/home/python/xxxx', '', '/usr/bin', '/usr/lib/python35.zip', '/usr/lib/python3.5', '/usr/lib/python3.5/plat-x86_64-linux-gnu', '/usr/lib/python3.5/lib-dynload', '/usr/local/lib/python3.5/dist-packages', '/usr/lib/python3/dist-packages', '/usr/lib/python3/dist-packages/IPython/extensions', '/home/python/.ipython'] 2. 重新导入模块 模块被导入后，import module不能重新导入模块，重新导入需用 测试模块内容 调用模块中的方法 修改测试模块 重新加载模块 "},"primary/zhi-shi-dian-shi-yi/xun-huan-dao-ru.html":{"url":"primary/zhi-shi-dian-shi-yi/xun-huan-dao-ru.html","title":"循环导入","keywords":"","body":"循环导入 循环导入 1. 什么是循环导入 a.py from b import b print '---------this is module a.py----------' def a(): print(\"hello, a\") b() a() b.py from a import a print '----------this is module b.py----------' def b(): print(\"hello, b\") def c(): a() c() 运行python a.py 2. 怎样避免循环导入 程序设计上分层，降低耦合 导入语句放在后面需要导入时再导入，例如放在函数体内导入 "},"primary/zhi-shi-dian-shi-yi/zuo-yong-yu.html":{"url":"primary/zhi-shi-dian-shi-yi/zuo-yong-yu.html","title":"作用域","keywords":"","body":"作用域 LEGB 规则 作用域 什么是命名空间 比如有一个学校，有10个班级，在7班和8班中都有一个叫“小王”的同学，如果在学校的广播中呼叫“小王”时，7班和8班中的这2个人就纳闷了，你是喊谁呢！！！如果是“7班的小王”的话，那么就很明确了，那么此时的7班就是小王所在的范围，即命名空间 globals、locals 在之前学习变量的作用域时，经常会提到局部变量和全局变量，之所有称之为局部、全局，就是因为他们的自作用的区域不同，这就是作用域 locals globals LEGB 规则 Python 使用 LEGB 的顺序来查找一个符号对应的对象 locals -> enclosing function -> globals -> builtins locals，当前所在命名空间（如函数、模块），函数的参数也属于命名空间内的变量 enclosing，外部嵌套函数的命名空间（闭包中常见）def fun1(): a = 10 def fun2(): # a 位于外部嵌套函数的命名空间 print(a) globals，全局变量，函数定义所在模块的命名空间a = 1 def fun(): # 需要通过 global 指令来声明全局变量 global a # 修改全局变量，而不是创建一个新的 local 变量 a = 2 builtins，内建模块的命名空间。 Python 在启动的时候会自动为我们载入很多内建的函数、类， 比如 dict，list，type，print，这些都位于 __builtin__ 模块中， 可以使用 dir(__builtin__) 来查看。 这也是为什么我们在没有 import任何模块的情况下， 就能使用这么多丰富的函数和功能了。 在Python中，有一个内建模块，该模块中有一些常用函数;在Python启动后， 且没有执行程序员所写的任何代码前，Python会首先加载该内建函数到内存。 另外，该内建模块中的功能可以直接使用，不用在其前添加内建模块前缀， 其原因是对函数、变量、类等标识符的查找是按LEGB法则，其中B即代表内建模块 比如：内建模块中有一个abs()函数，其功能求绝对值，如abs(-20)将返回20。 "},"primary/zhi-shi-dian-shi-yi/is.html":{"url":"primary/zhi-shi-dian-shi-yi/is.html","title":"==、is","keywords":"","body":"==、is ==、is 总结 is 是比较两个引用是否指向了同一个对象（引用比较）。 == 是比较两个对象是否相等。 "},"primary/zhi-shi-dian-shi-yi/shen-kao-bei-3001-qian-kao-bei.html":{"url":"primary/zhi-shi-dian-shi-yi/shen-kao-bei-3001-qian-kao-bei.html","title":"深拷贝、浅拷贝","keywords":"","body":"深拷贝、浅拷贝 深拷贝 拷贝的其他方式 总结 深拷贝、浅拷贝 浅拷贝 浅拷贝是对于一个对象的顶层拷贝 通俗的理解是：拷贝了引用，并没有拷贝内容 深拷贝 深拷贝是对于一个对象所有层次的拷贝(递归) 进一步理解拷贝 In [23]: a = [11,22,33] In [24]: b = [44,55,66] In [25]: c = (a,b) In [26]: e = copy.deepcopy(c) In [27]: a.append(77) In [28]: a Out[28]: [11, 22, 33, 77] In [29]: b Out[29]: [44, 55, 66] In [30]: c Out[30]: ([11, 22, 33, 77], [44, 55, 66]) In [31]: e Out[31]: ([11, 22, 33], [44, 55, 66]) In [32]: In [32]: In [32]: f = copy.copy(c) In [33]: a.append(88) In [34]: a Out[34]: [11, 22, 33, 77, 88] In [35]: b Out[35]: [44, 55, 66] In [36]: c Out[36]: ([11, 22, 33, 77, 88], [44, 55, 66]) In [37]: e Out[37]: ([11, 22, 33], [44, 55, 66]) In [38]: f Out[38]: ([11, 22, 33, 77, 88], [44, 55, 66]) 拷贝的其他方式 浅拷贝对不可变类型和可变类型的copy不同 In [88]: a = [11,22,33] In [89]: b = copy.copy(a) In [90]: id(a) Out[90]: 59275144 In [91]: id(b) Out[91]: 59525600 In [92]: a.append(44) In [93]: a Out[93]: [11, 22, 33, 44] In [94]: b Out[94]: [11, 22, 33] In [95]: In [95]: In [95]: a = (11,22,33) In [96]: b = copy.copy(a) In [97]: id(a) Out[97]: 58890680 In [98]: id(b) Out[98]: 58890680 分片表达式可以赋值一个序列 a = \"abc\" b = a[:] 字典的copy方法可以拷贝一个字典 d = dict(name=\"zhangsan\", age=27) co = d.copy() 有些内置函数可以生成拷贝(list) a = list(range(10)) b = list(a) copy模块中的copy函数 import copy a = (1,2,3) b = copy.copy(a) 总结 copy.copy()作用在不可变类型上时，是浅拷贝，其他类型是深拷贝 "},"primary/zhi-shi-dian-shi-yi/jin-zhi-3001-wei-yun-suan.html":{"url":"primary/zhi-shi-dian-shi-yi/jin-zhi-3001-wei-yun-suan.html","title":"进制、位运算","keywords":"","body":"进制、位运算 进制、位运算 1、什么是进制 1）理解个X进制的概念 : 每一位 只允许出现 0~X-1 这几个数字,逢X进一,基是X, 每一位有一个权值大小是X的幂次。 其表示的数值可以写成按位权展开的多项式之和。 十进制: 每一位只允许出现0~9这十个数字,逢十进1,基是十,每一位数字有一个 权值大小是十的幂次。 其表示的数值可以写成按位权展开的多项式之和。 二进制: 每一位只允许出现0~1这二个数字,逢二进1,基是 二, 每一位数字有一个权值大小是二的幂次。 其表示的数值可以写成按位权展开的多项式之和。 八进制:逢八进一 十六进制：逢十六进一 2） 假如用两个字节表示 一个整数， 如下： 十进制数字1 的二进制表现形式: 0000 0000 0000 0001 十进制数字2 的二进制表现形式: 0000 0000 0000 0010 如何表示二进制数的正负？ 3）有符号数和无符号数的概念 规则：把二进制数中的最高位（最左边的那位）用作符号位 对于有符号数，最高位被计算机系统规定为符号位(0为正,1为负) 对于无符号数，最高位被计算机系统规定为数据位 按照这种说法，比如有符号数 +2 -2 的原码形式： +2 = 0000 0000 0000 0010 -2 = 1000 0000 0000 0010 真值 机器数 +1 = 0000 0000 0000 0001 -1 = 1000 0000 0000 0001 ----------------------------------------- 1000 0000 0000 0010 -1+1 的结果？ -1+1 = 1000 0000 0000 0010 ----》 -2 不等于0，按理说-1+1等于0才对，为什么会是-2呢？ 规则 数字在计算机中，是用二进制补码的形式来保存的，因此-1 +1需要按照补码进行相加才是正确的结果 2、原码、反码、补码 1）如何计算补码？ 规则: 正数：原码 = 反码 = 补码 负数：反码 = 符号位不变，其他位取反 补码 = 反码+1 1 的原码：0000 0000 0000 0001 -1的原码：1000 0000 0000 0001 -1的反码：1111 1111 1111 1110 -1的补码：1111 1111 1111 1111 重新计算 -1+1 结果 1111 1111 1111 1111 0000 0000 0000 0001 --------------------------- 0000 0000 0000 0000 2）从补码转回原码 负数补码转换原码的规则: 原码 = 补码的符号位不变 -->数据位取反--> 尾+1 -1的补码:1111 1111 1111 1111 取反:1000 0000 0000 0000 -1的原码:1000 0000 0000 0001 【了解】 可以把减法用加法来算，只需设计加法器就好了。运算的时候都是用补码去运算的。 2-1 = 2+(-1)=0000 0000 0000 0010 +1111 1111 1111 1111 【了解】 为何要使用原码, 反码和补码 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢? 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对应加减，但是对于计算机，加减乘数已经是最基础的运算, 要设计的尽量简单。计算机辨别\"符号位\"显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法. 我们知道，根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.于是人们开始探索 将符号位参与运算, 并且只保留加法的方法 3. 进制间转换 #10进制转为2进制 >>> bin(10) '0b1010' #2进制转为10进制 >>> int(\"1001\",2) 9 #10进制转为16进制 >>> hex(10) '0xa' #16进制到10进制 >>> int('ff', 16) 255 >>> int('0xab', 16) 171 #16进制到2进制 >>> bin(0xa) '0b1010' >>> #10进制到8进制 >>> oct(8) '010' #2进制到16进制 >>> hex(0b1001) '0x9' 4. 位运算 看如下示例: 如果有一个十进制数 5，其二进制为:0000 0101 把所有的数向左移动一位 其结果为:0000 1010 想一想:二进制 0000 1010 十进制是多少呢？？？其答案为10，有没有发现是5的2倍呢！ 再假设有一个十进制数 3， 其二进制 为:0000 0011 把所有的数向左移动一位 其结果为:0000 0110 二进制0000 0110 的十进制为6，正好也是3的2倍 通过以上2个例子，能够看出，把一个数的各位整体向左移动一个位，就变成原来的2倍 那么在Python中，怎样实现向左移动呢？还有其他的吗？？？ 位运算的介绍 & 按位与 | 按位或 ^ 按位异或 ~ 按位取反 >> 按位右移 用途: 直接操作二进制,省内存,效率高 位运算 1） 各二进位全部左移n位,高位丢弃,低位补0 x 【注意事项】 a. 左移1位相当于 乘以2 用途:快速计算一个数乘以2的n次方 (8 b.左移可能会改变一个数的正负性 2)>> 右移 各二进位全部右移n位,保持符号位不变 x >> n x的所有二进制位向右移动n位,移出的位删掉,移进的位补符号位 右移不会改变一个数的符号 【注意事项】 右移1位相当于 除以2 x 右移 n 位就相当于除以2的n次方 用途:快速计算一个数除以2的n次方 (8>>3 等同于8/2^3) 3)& 按位与 全1才1否则0 :只有对应的两个二进位均为1时,结果位才为1,否则为0 用6和3这个例子。不要用9 和13的例子 4) | 按位或 有1就1 只要对应的二个二进位有一个为1时,结果位就为1,否则为0 5) ^ 按位异或 不同为1 当对应的二进位相异(不相同)时,结果为1,否则为0 6) ~ 取反 ~9 = -10 【为什么9取反变成了-10的说明】： 9的原码 ==> 0000 1001 因为正数的原码=反码=补码，所以在 真正存储的时候就是0000 1001 接下来进行对9的补码进行取反操作 进行取反==> 1111 0110 这就是对9 进行了取反之后的补码 既然已经知道了补码，那么接下来只要转换为 咱们人能识别的码型就可以，因此按照规则 ，把这个1111 0110 这个补码 转换为原码即可 符号位不变，其它位取反==> 1000 1001 然后+1 ，得到原码 =======>1000 1010 这就是 -10 【扩展】 1)任何数和1进行&操作,得到这个数的最低位 数字&1 = 数字的二进制形式的最低位 2)位运算优先级 "},"primary/zhi-shi-dian-shi-yi/si-you-hua.html":{"url":"primary/zhi-shi-dian-shi-yi/si-you-hua.html","title":"私有化","keywords":"","body":"私有化 私有化 xx: 公有变量 _x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问 __xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到) __xx__:双前后下划线,用户名字空间的魔法对象或属性。例如:__init__, __ 不要自己发明这样的名字 xx_:单后置下划线,用于避免与Python关键词的冲突 通过name mangling（名字重整(目的就是以防子类意外重写基类的方法或者属性)如：_Class__object）机制就可以访问private了。 #coding=utf-8 class Person(object): def __init__(self, name, age, taste): self.name = name self._age = age self.__taste = taste def showperson(self): print(self.name) print(self._age) print(self.__taste) def dowork(self): self._work() self.__away() def _work(self): print('my _work') def __away(self): print('my __away') class Student(Person): def construction(self, name, age, taste): self.name = name self._age = age self.__taste = taste def showstudent(self): print(self.name) print(self._age) print(self.__taste) @staticmethod def testbug(): _Bug.showbug() #模块内可以访问，当from cur_module import *时，不导入 class _Bug(object): @staticmethod def showbug(): print(\"showbug\") s1 = Student('jack', 25, 'football') s1.showperson() print('*'*20) #无法访问__taste,导致报错 #s1.showstudent() s1.construction('rose', 30, 'basketball') s1.showperson() print('*'*20) s1.showstudent() print('*'*20) Student.testbug() 总结 父类中属性名为__名字的，子类不继承，子类不能访问 如果在子类中向__名字赋值，那么会在子类中定义的一个与父类相同名字的属性 _名的变量、函数、类在使用from xxx import *时都不会被导入 "},"primary/zhi-shi-dian-shi-yi/shu-xing-property.html":{"url":"primary/zhi-shi-dian-shi-yi/shu-xing-property.html","title":"属性property","keywords":"","body":"属性property 属性property 1. 私有属性添加getter和setter方法 class Money(object): def __init__(self): self.__money = 0 def getMoney(self): return self.__money def setMoney(self, value): if isinstance(value, int): self.__money = value else: print(\"error:不是整型数字\") 2. 使用property升级getter和setter方法 class Money(object): def __init__(self): self.__money = 0 def getMoney(self): return self.__money def setMoney(self, value): if isinstance(value, int): self.__money = value else: print(\"error:不是整型数字\") money = property(getMoney, setMoney) 运行结果: In [1]: from get_set import Money In [2]: In [2]: a = Money() In [3]: In [3]: a.money Out[3]: 0 In [4]: a.money = 100 In [5]: a.money Out[5]: 100 In [6]: a.getMoney() Out[6]: 100 3. 使用property取代getter和setter方法 @property成为属性函数，可以对属性赋值时做必要的检查，并保证代码的清晰短小，主要有2个作用 将方法转换为只读 重新实现一个属性的设置和读取方法,可做边界判定 class Money(object): def __init__(self): self.__money = 0 @property def money(self): return self.__money @money.setter def money(self, value): if isinstance(value, int): self.__money = value else: print(\"error:不是整型数字\") 运行结果 In [3]: a = Money() In [4]: In [4]: In [4]: a.money Out[4]: 0 In [5]: a.money = 100 In [6]: a.money Out[6]: 100 "},"primary/zhi-shi-dian-shi-yi/la-ji-hui-shou.html":{"url":"primary/zhi-shi-dian-shi-yi/la-ji-hui-shou.html","title":"垃圾回收","keywords":"","body":"垃圾回收（一） 垃圾回收(二) 1. Garbage collection(GC垃圾回收) 2. 画说 Ruby 与 Python 垃圾回收 2.1 应用程序那颗跃动的心 2.2 一个简单的例子 2.3 Ruby 的对象分配 2.4 Python 的对象分配 2.5 Ruby 开发者住在凌乱的房间里 2.6 Python 开发者住在卫生之家庭 2.7 标记-清除 2.8 标记-删除 vs. 引用计数 3. Python中的循环数据结构以及引用计数 3.1 循环引用 3.2 在Python中的零代(Generation Zero) 3.3 检测循环引用 Python中的GC阈值 垃圾回收(三)-gc模块 一.垃圾回收机制 1、导致引用计数+1的情况 2、导致引用计数-1的情况 3、查看一个对象的引用计数 二.循环引用导致内存泄露 三.垃圾回收 有三种情况会触发垃圾回收： 四.gc模块常用功能解析 注意点 垃圾回收（一） 小整数对象池 整数在程序中的使用非常广泛，Python为了优化速度，使用了小整数对象池， 避免为整数频繁申请和销毁内存空间。 Python 对小整数的定义是 [-5, 257) 这些整数对象是提前建立好的，不会被垃圾回收。在一个 Python 的程序中，所有位于这个范围内的整数使用的都是同一个对象. 同理，单个字母也是这样的。 但是当定义2个相同的字符串时，引用计数为0，触发垃圾回收 大整数对象池 每一个大整数，均创建一个新的对象。 intern机制 a1 = \"HelloWorld\" a2 = \"HelloWorld\" a3 = \"HelloWorld\" a4 = \"HelloWorld\" a5 = \"HelloWorld\" a6 = \"HelloWorld\" a7 = \"HelloWorld\" a8 = \"HelloWorld\" a9 = \"HelloWorld\" python会不会创建9个对象呢？在内存中会不会开辟9个”HelloWorld”的内存空间呢？ 想一下，如果是这样的话，我们写10000个对象，比如a1=”HelloWorld”…..a1000=”HelloWorld”， 那他岂不是开辟了1000个”HelloWorld”所占的内存空间了呢？如果真这样，内存不就爆了吗？所以python中有这样一个机制——intern机制，让他只占用一个”HelloWorld”所占的内存空间。靠引用计数去维护何时释放。 总结 小整数[-5,257)共用对象，常驻内存 单个字符共用对象，常驻内存 单个单词，不可修改，默认开启intern机制，共用对象，引用计数为0，则销毁 字符串（含有空格），不可修改，没开启intern机制，不共用对象，引用计数为0，销毁 大整数不共用内存，引用计数为0，销毁 数值类型和字符串类型在 Python 中都是不可变的，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象 垃圾回收(二) 1. Garbage collection(GC垃圾回收) 现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。 对于一个字符串、列表、类甚至数值都是对象，且定位简单易用的语言，自然不会让用户去处理如何分配回收内存的问题。 python里也同java一样采用了垃圾收集机制，不过不一样的是: python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略 引用计数机制： python里每一个东西都是对象，它们的核心就是一个结构体：PyObject typedef struct_object { int ob_refcnt; struct_typeobject *ob_type; } PyObject; PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少 #define Py_INCREF(op) ((op)->ob_refcnt++) //增加计数 #define Py_DECREF(op) \\ //减少计数 if (--(op)->ob_refcnt != 0) \\ ; \\ else \\ __Py_Dealloc((PyObject *)(op)) 当引用计数为0时，该对象生命就结束了。 引用计数机制的优点： 简单 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。 引用计数机制的缺点： 维护引用计数消耗资源 循环引用list1 = [] list2 = [] list1.append(list2) list2.append(list1) list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。 对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制。(标记清除和分代收集) 2. 画说 Ruby 与 Python 垃圾回收 英文原文:visualizing garbage collection in ruby and python 2.1 应用程序那颗跃动的心 GC系统所承担的工作远比\"垃圾回收\"多得多。实际上，它们负责三个重要任务。它们 为新生成的对象分配内存 识别那些垃圾对象，并且 从垃圾对象那回收内存。 如果将应用程序比作人的身体：所有你所写的那些优雅的代码，业务逻辑，算法，应该就是大脑。以此类推，垃圾回收机制应该是那个身体器官呢？（我从RuPy听众那听到了不少有趣的答案：腰子、白血球 :) ） 我认为垃圾回收就是应用程序那颗跃动的心。像心脏为身体其他器官提供血液和营养物那样，垃圾回收器为你的应该程序提供内存和对象。如果心脏停跳，过不了几秒钟人就完了。如果垃圾回收器停止工作或运行迟缓,像动脉阻塞,你的应用程序效率也会下降，直至最终死掉。 2.2 一个简单的例子 运用实例一贯有助于理论的理解。下面是一个简单类，分别用Python和Ruby写成，我们今天就以此为例： 顺便提一句，两种语言的代码竟能如此相像：Ruby 和 Python 在表达同一事物上真的只是略有不同。但是在这两种语言的内部实现上是否也如此相似呢？ 2.3 Ruby 的对象分配 当我们执行上面的Node.new(1)时，Ruby到底做了什么？Ruby是如何为我们创建新的对象的呢？ 出乎意料的是它做的非常少。实际上，早在代码开始执行前，Ruby就提前创建了成百上千个对象，并把它们串在链表上，名曰：可用列表。下图所示为可用列表的概念图： 想象一下每个白色方格上都标着一个\"未使用预创建对象\"。当我们调用 Node.new ,Ruby只需取一个预创建对象给我们使用即可： 上图中左侧灰格表示我们代码中使用的当前对象，同时其他白格是未使用对象。(请注意：无疑我的示意图是对实际的简化。实际上，Ruby会用另一个对象来装载字符串\"ABC\",另一个对象装载Node类定义，还有一个对象装载了代码中分析出的抽象语法树，等等) 如果我们再次调用 Node.new，Ruby将递给我们另一个对象： 这个简单的用链表来预分配对象的算法已经发明了超过50年，而发明人这是赫赫有名的计算机科学家John McCarthy，一开始是用Lisp实现的。Lisp不仅是最早的函数式编程语言，在计算机科学领域也有许多创举。其一就是利用垃圾回收机制自动化进行程序内存管理的概念。 标准版的Ruby，也就是众所周知的\"Matz's Ruby Interpreter\"(MRI),所使用的GC算法与McCarthy在1960年的实现方式很类似。无论好坏，Ruby的垃圾回收机制已经53岁高龄了。像Lisp一样，Ruby预先创建一些对象，然后在你分配新对象或者变量的时候供你使用。 2.4 Python 的对象分配 我们已经了解了Ruby预先创建对象并将它们存放在可用列表中。那Python又怎么样呢？ 尽管由于许多原因Python也使用可用列表(用来回收一些特定对象比如 list)，但在为新对象和变量分配内存的方面Python和Ruby是不同的。 例如我们用Pyhon来创建一个Node对象： 与Ruby不同，当创建对象时Python立即向操作系统请求内存。(Python实际上实现了一套自己的内存分配系统，在操作系统堆之上提供了一个抽象层。但是我今天不展开说了。) 当我们创建第二个对象的时候，再次像OS请求内存： 看起来够简单吧，在我们创建对象的时候，Python会花些时间为我们找到并分配内存。 2.5 Ruby 开发者住在凌乱的房间里 Ruby把无用的对象留在内存里，直到下一次GC执行 回过来看Ruby。随着我们创建越来越多的对象，Ruby会持续寻可用列表里取预创建对象给我们。因此，可用列表会逐渐变短: ...然后更短： 请注意我一直在为变量n1赋新值，Ruby把旧值留在原处。\"ABC\",\"JKL\"和\"MNO\"三个Node实例还滞留在内存中。Ruby不会立即清除代码中不再使用的旧对象！Ruby开发者们就像是住在一间凌乱的房间，地板上摞着衣服，要么洗碗池里都是脏盘子。作为一个Ruby程序员，无用的垃圾对象会一直环绕着你。 2.6 Python 开发者住在卫生之家庭 用完的垃圾对象会立即被Python打扫干净 Python与Ruby的垃圾回收机制颇为不同。让我们回到前面提到的三个Python Node对象： 在内部，创建一个对象时，Python总是在对象的C结构体里保存一个整数，称为引用数。期初，Python将这个值设置为1： 值为1说明分别有个一个指针指向或是引用这三个对象。假如我们现在创建一个新的Node实例，JKL： 与之前一样，Python设置JKL的引用数为1。然而，请注意由于我们改变了n1指向了JKL，不再指向ABC，Python就把ABC的引用数置为0了。 此刻，Python垃圾回收器立刻挺身而出！每当对象的引用数减为0，Python立即将其释放，把内存还给操作系统： 上面Python回收了ABC Node实例使用的内存。记住，Ruby弃旧对象原地于不顾，也不释放它们的内存。 Python的这种垃圾回收算法被称为引用计数。是George-Collins在1960年发明的，恰巧与John McCarthy发明的可用列表算法在同一年出现。就像Mike-Bernstein在6月份哥谭市Ruby大会杰出的垃圾回收机制演讲中说的: \"1960年是垃圾收集器的黄金年代...\" Python开发者工作在卫生之家,你可以想象，有个患有轻度OCD(一种强迫症)的室友一刻不停地跟在你身后打扫，你一放下脏碟子或杯子，有个家伙已经准备好把它放进洗碗机了！ 现在来看第二例子。加入我们让n2引用n1： 上图中左边的DEF的引用数已经被Python减少了，垃圾回收器会立即回收DEF实例。同时JKL的引用数已经变为了2 ，因为n1和n2都指向它。 2.7 标记-清除 最终那间凌乱的房间充斥着垃圾，再不能岁月静好了。在Ruby程序运行了一阵子以后，可用列表最终被用光光了: 此刻所有Ruby预创建对象都被程序用过了(它们都变灰了)，可用列表里空空如也（没有白格子了）。 此刻Ruby祭出另一McCarthy发明的算法，名曰：标记-清除。首先Ruby把程序停下来，Ruby用\"地球停转垃圾回收大法\"。之后Ruby轮询所有指针，变量和代码产生别的引用对象和其他值。同时Ruby通过自身的虚拟机便利内部指针。标记出这些指针引用的每个对象。我在图中使用M表示。 上图中那三个被标M的对象是程序还在使用的。在内部，Ruby实际上使用一串位值，被称为:可用位图(译注：还记得《编程珠玑》里的为突发排序吗，这对离散度不高的有限整数集合具有很强的压缩效果，用以节约机器的资源。)，来跟踪对象是否被标记了。 如果说被标记的对象是存活的，剩下的未被标记的对象只能是垃圾，这意味着我们的代码不再会使用它了。我会在下图中用白格子表示垃圾对象： 接下来Ruby清除这些无用的垃圾对象，把它们送回到可用列表中： 在内部这一切发生得迅雷不及掩耳，因为Ruby实际上不会吧对象从这拷贝到那。而是通过调整内部指针，将其指向一个新链表的方式，来将垃圾对象归位到可用列表中的。 现在等到下回再创建对象的时候Ruby又可以把这些垃圾对象分给我们使用了。在Ruby里，对象们六道轮回，转世投胎，享受多次人生。 2.8 标记-删除 vs. 引用计数 乍一看，Python的GC算法貌似远胜于Ruby的：宁舍洁宇而居秽室乎？为什么Ruby宁愿定期强制程序停止运行，也不使用Python的算法呢？ 然而，引用计数并不像第一眼看上去那样简单。有许多原因使得不许多语言不像Python这样使用引用计数GC算法： 首先，它不好实现。Python不得不在每个对象内部留一些空间来处理引用数。这样付出了一小点儿空间上的代价。但更糟糕的是，每个简单的操作（像修改变量或引用）都会变成一个更复杂的操作，因为Python需要增加一个计数，减少另一个，还可能释放对象。 第二点，它相对较慢。虽然Python随着程序执行GC很稳健（一把脏碟子放在洗碗盆里就开始洗啦），但这并不一定更快。Python不停地更新着众多引用数值。特别是当你不再使用一个大数据结构的时候，比如一个包含很多元素的列表，Python可能必须一次性释放大量对象。减少引用数就成了一项复杂的递归过程了。 最后，它不是总奏效的。引用计数不能处理环形数据结构--也就是含有循环引用的数据结构。 3. Python中的循环数据结构以及引用计数 3.1 循环引用 通过上篇，我们知道在Python中，每个对象都保存了一个称为引用计数的整数值，来追踪到底有多少引用指向了这个对象。无论何时，如果我们程序中的一个变量或其他对象引用了目标对象，Python将会增加这个计数值，而当程序停止使用这个对象，则Python会减少这个计数值。一旦计数值被减到零，Python将会释放这个对象以及回收相关内存空间。 从六十年代开始，计算机科学界就面临了一个严重的理论问题，那就是针对引用计数这种算法来说，如果一个数据结构引用了它自身，即如果这个数据结构是一个循环数据结构，那么某些引用计数值是肯定无法变成零的。为了更好地理解这个问题，让我们举个例子。下面的代码展示了一些上周我们所用到的节点类： 我们有一个\"构造器\"(在Python中叫做 __init__ )，在一个实例变量中存储一个单独的属性。在类定义之后我们创建两个节点，ABC以及DEF，在图中为左边的矩形框。两个节点的引用计数都被初始化为1，因为各有两个引用指向各个节点(n1和n2)。 现在，让我们在节点中定义两个附加的属性，next以及prev： 跟Ruby不同的是，Python中你可以在代码运行的时候动态定义实例变量或对象属性。这看起来似乎有点像Ruby缺失了某些有趣的魔法。(声明下我不是一个Python程序员，所以可能会存在一些命名方面的错误)。我们设置 n1.next 指向 n2，同时设置 n2.prev 指回 n1。现在，我们的两个节点使用循环引用的方式构成了一个双向链表。同时请注意到 ABC 以及 DEF 的引用计数值已经增加到了2。这里有两个指针指向了每个节点：首先是 n1 以及 n2，其次就是 next 以及 prev。 现在，假定我们的程序不再使用这两个节点了，我们将 n1 和 n2 都设置为null(Python中是None)。 好了，Python会像往常一样将每个节点的引用计数减少到1。 3.2 在Python中的零代(Generation Zero) 请注意在以上刚刚说到的例子中，我们以一个不是很常见的情况结尾：我们有一个“孤岛”或是一组未使用的、互相指向的对象，但是谁都没有外部引用。换句话说，我们的程序不再使用这些节点对象了，所以我们希望Python的垃圾回收机制能够足够智能去释放这些对象并回收它们占用的内存空间。但是这不可能，因为所有的引用计数都是1而不是0。Python的引用计数算法不能够处理互相指向自己的对象。 这就是为什么Python要引入Generational GC算法的原因！正如Ruby使用一个链表(free list)来持续追踪未使用的、自由的对象一样，Python使用一种不同的链表来持续追踪活跃的对象。而不将其称之为“活跃列表”，Python的内部C代码将其称为零代(Generation Zero)。每次当你创建一个对象或其他什么值的时候，Python会将其加入零代链表： 从上边可以看到当我们创建ABC节点的时候，Python将其加入零代链表。请注意到这并不是一个真正的列表，并不能直接在你的代码中访问，事实上这个链表是一个完全内部的Python运行时。 相似的，当我们创建DEF节点的时候，Python将其加入同样的链表： 现在零代包含了两个节点对象。(他还将包含Python创建的每个其他值，与一些Python自己使用的内部值。) 3.3 检测循环引用 随后，Python会循环遍历零代列表上的每个对象，检查列表中每个互相引用的对象，根据规则减掉其引用计数。在这个过程中，Python会一个接一个的统计内部引用的数量以防过早地释放对象。 为了便于理解，来看一个例子： 从上面可以看到 ABC 和 DEF 节点包含的引用数为1.有三个其他的对象同时存在于零代链表中，蓝色的箭头指示了有一些对象正在被零代链表之外的其他对象所引用。(接下来我们会看到，Python中同时存在另外两个分别被称为一代和二代的链表)。这些对象有着更高的引用计数因为它们正在被其他指针所指向着。 接下来你会看到Python的GC是如何处理零代链表的。 通过识别内部引用，Python能够减少许多零代链表对象的引用计数。在上图的第一行中你能够看见ABC和DEF的引用计数已经变为零了，这意味着收集器可以释放它们并回收内存空间了。剩下的活跃的对象则被移动到一个新的链表：一代链表。 从某种意义上说，Python的GC算法类似于Ruby所用的标记回收算法。周期性地从一个对象到另一个对象追踪引用以确定对象是否还是活跃的，正在被程序所使用的，这正类似于Ruby的标记过程。 Python中的GC阈值 Python什么时候会进行这个标记过程？随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。 当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。 随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。 通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。 弱代假说 来看看代垃圾回收算法的核心行为：垃圾回收器会更频繁的处理新对象。一个新的对象即是你的程序刚刚创建的，而一个来的对象则是经过了几个时间周期之后仍然存在的对象。Python会在当一个对象从零代移动到一代，或是从一代移动到二代的过程中提升(promote)这个对象。 为什么要这么做？这种算法的根源来自于弱代假说(weak generational hypothesis)。这个假说由两个观点构成：首先是年亲的对象通常死得也快，而老对象则很有可能存活更长的时间。 假定现在我用Python或是Ruby创建一个新对象： 根据假说，我的代码很可能仅仅会使用ABC很短的时间。这个对象也许仅仅只是一个方法中的中间结果，并且随着方法的返回这个对象就将变成垃圾了。大部分的新对象都是如此般地很快变成垃圾。然而，偶尔程序会创建一些很重要的，存活时间比较长的对象-例如web应用中的session变量或是配置项。 通过频繁的处理零代链表中的新对象，Python的垃圾收集器将把时间花在更有意义的地方：它处理那些很快就可能变成垃圾的新对象。同时只在很少的时候，当满足阈值的条件，收集器才回去处理那些老变量。 垃圾回收(三)-gc模块 一.垃圾回收机制 Python中的垃圾回收是以引用计数为主，分代收集为辅。 1、导致引用计数+1的情况 对象被创建，例如a=23 对象被引用，例如b=a 对象被作为参数，传入到一个函数中，例如func(a) 对象作为一个元素，存储在容器中，例如list1=[a,a] 2、导致引用计数-1的情况 对象的别名被显式销毁，例如del a 对象的别名被赋予新的对象，例如a=24 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会） 对象所在的容器被销毁，或从容器中删除对象 3、查看一个对象的引用计数 import sys a = \"hello world\" sys.getrefcount(a) 可以查看a对象的引用计数，但是比正常计数大1，因为调用函数的时候传入a，这会让a的引用计数+1 二.循环引用导致内存泄露 引用计数的缺陷是循环引用的问题 import gc class ClassA(): def __init__(self): print('object born,id:%s'%str(hex(id(self)))) def f2(): while True: c1 = ClassA() c2 = ClassA() c1.t = c2 c2.t = c1 del c1 del c2 #把python的gc关闭 gc.disable() f2() 执行f2()，进程占用的内存会不断增大。 创建了c1，c2后这两块内存的引用计数都是1，执行 c1.t=c2 和 c2.t=c1 后，这两块内存的引用计数变成2. 在del c1后，内存1的对象的引用计数变为1，由于不是为0，所以内存1的对象不会被销毁，所以内存2的对象的引用数依然是2，在del c2后，同理，内存1的对象，内存2的对象的引用数都是1。 虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。 三.垃圾回收 #coding=utf-8 import gc class ClassA(): def __init__(self): print('object born,id:%s'%str(hex(id(self)))) # def __del__(self): # print('object del,id:%s'%str(hex(id(self)))) def f3(): print(\"-----0------\") # print(gc.collect()) c1 = ClassA() c2 = ClassA() c1.t = c2 c2.t = c1 print(\"-----1------\") del c1 del c2 print(\"-----2------\") print(gc.garbage) print(\"-----3------\") print(gc.collect()) #显式执行垃圾回收 print(\"-----4------\") print(gc.garbage) print(\"-----5------\") if __name__ == '__main__': gc.set_debug(gc.DEBUG_LEAK) #设置gc模块的日志 f3() python2运行结果: -----0------ object born,id:0x724b20 object born,id:0x724b48 -----1------ -----2------ [] -----3------ gc: collectable gc: collectable gc: collectable gc: collectable 4 -----4------ [, , {'t': }, {'t': }] -----5------ 说明: 垃圾回收后的对象会放在gc.garbage列表里面 gc.collect()会返回不可达的对象数目，4等于两个对象以及它们对应的dict 有三种情况会触发垃圾回收： 调用gc.collect(), 当gc模块的计数器达到阀值的时候。 程序退出的时候 四.gc模块常用功能解析 gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。 常用函数： 1、gc.set_debug(flags) 设置gc的debug日志，一般设置为gc.DEBUG_LEAK 2、gc.collect([generation]) 显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。 返回不可达（unreachable objects）对象的数目 3、gc.get_threshold() 获取的gc模块中自动执行垃圾回收的频率。 4、gc.set_threshold(threshold0[, threshold1[, threshold2]) 设置自动执行垃圾回收的频率。 5、gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表 gc模块的自动垃圾回收机制 必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。 这个机制的主要作用就是发现并处理不可达的垃圾对象。 垃圾回收=垃圾检查+垃圾回收 在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。 gc模块里面会有一个长度为3的列表的计数器，可以通过gc.get_count()获取。 例如(488,3,0)，其中488是指距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数的增加。例如： print gc.get_count() # (590, 8, 0) a = ClassA() print gc.get_count() # (591, 8, 0) del a print gc.get_count() # (590, 8, 0) 3是指距离上一次二代垃圾检查，一代垃圾检查的次数，同理，0是指距离上一次三代垃圾检查，二代垃圾检查的次数。 gc模快有一个自动垃圾回收的阀值，即通过gc.get_threshold函数获取到的长度为3的元组，例如(700,10,10) 每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器 例如，假设阀值是(700,10,10)： 当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查一代对象的垃圾，并重置计数器为(0,4,0) 当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查一、二代对象的垃圾，并重置计数器为(0,0,1) 当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0) 注意点 gc模块唯一处理不了的是循环引用的类都有__del__方法，所以项目中要避免定义__del__方法 import gc class ClassA(): pass # def __del__(self): # print('object born,id:%s'%str(hex(id(self)))) gc.set_debug(gc.DEBUG_LEAK) a = ClassA() b = ClassA() a.next = b b.prev = a print \"--1--\" print gc.collect() print \"--2--\" del a print \"--3--\" del b print \"--3-1--\" print gc.collect() print \"--4--\" 运行结果： --1-- 0 --2-- --3-- --3-1-- gc: collectable gc: collectable gc: collectable gc: collectable 4 --4-- 如果把del打开，运行结果为: --1-- 0 --2-- --3-- --3-1-- gc: uncollectable gc: uncollectable gc: uncollectable gc: uncollectable 4 --4-- "},"primary/zhi-shi-dian-shi-yi/nei-jian-shu-xing-3001-nei-jian-han-shu.html":{"url":"primary/zhi-shi-dian-shi-yi/nei-jian-shu-xing-3001-nei-jian-han-shu.html","title":"内建属性、内建函数","keywords":"","body":"内建属性 内建函数 内建属性 \"teachclass.py\" class Person(object): pass python3.5中类的内建属性和方法 经典类(旧式类),早期如果没有要继承的父类,继承里空着不写的类 #py2中无继承父类，称之经典类,py3中已默认继承object class Person: pass 子类没有实现__init__方法时，默认自动调用父类的。 如定义__init__方法时，需自己手动调用父类的__init__方法 常用专有属性 说明 触发方式 __init__ 构造初始化函数 创建实例后,赋值时使用,在__new__后 __new__ 生成实例所需属性 创建实例时 __class__ 实例所在的类 实例.__class__ __str__ 实例字符串表示,可读性 print(类实例),如没实现，使用repr结果 __repr__ 实例字符串表示,准确性 类实例 回车 或者 print(repr(类实例)) __del__ 析构 del删除实例 __dict__ 实例自定义属性 vars(实例.__dict__) __doc__ 类文档,子类不继承 help(类或实例) __getattribute__ 属性访问拦截器 访问实例属性时 __bases__ 类的所有父类构成元素 类名.__bases__ __getattribute__例子: class Itcast(object): def __init__(self,subject1): self.subject1 = subject1 self.subject2 = 'cpp' #属性访问时拦截器，打log def __getattribute__(self,obj): if obj == 'subject1': print('log subject1') return 'redirect python' else: #测试时注释掉这2行，将找不到subject2 return object.__getattribute__(self,obj) def show(self): print('this is Itcast') s = Itcast(\"python\") print(s.subject1) print(s.subject2) 运行结果: log subject1 redirect python cpp __getattribute__的坑 class Person(object): def __getattribute__(self,obj): print(\"---test---\") if obj.startswith(\"a\"): return \"hahha\" else: return self.test def test(self): print(\"heihei\") t.Person() t.a #返回hahha t.b #会让程序死掉 #原因是：当t.b执行时，会调用Person类中定义的__getattribute__方法，但是在这个方法的执行过程中 #if条件不满足，所以 程序执行else里面的代码，即return self.test 问题就在这，因为return 需要把 #self.test的值返回，那么首先要获取self.test的值，因为self此时就是t这个对象，所以self.test就是 #t.test 此时要获取t这个对象的test属性，那么就会跳转到__getattribute__方法去执行，即此时产 #生了递归调用，由于这个递归过程中 没有判断什么时候推出，所以这个程序会永无休止的运行下去，又因为 #每次调用函数，就需要保存一些数据，那么随着调用的次数越来越多，最终内存吃光，所以程序 崩溃 # # 注意：以后不要在__getattribute__方法中调用self.xxxx 内建函数 Build-in Function,启动python解释器，输入dir(__builtins__), 可以看到很多python解释器启动后默认加载的属性和函数，这些函数称之为内建函数， 这些函数因为在编程时使用较多，cpython解释器用c语言实现了这些函数，启动解释器 时默认加载。 这些函数数量众多，不宜记忆，开发时不是都用到的，待用到时再help(function), 查看如何使用，或结合百度查询即可，在这里介绍些常用的内建函数。 range range(stop) -> list of integers range(start, stop[, step]) -> list of integers start:计数从start开始。默认是从0开始。例如range（5）等价于range（0， 5）; stop:到stop结束，但不包括stop.例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5 step:每次跳跃的间距，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1) python2中range返回列表，python3中range返回一个迭代值。如果想得到列表,可通过list函数 a = range(5) list(a) 创建列表的另外一种方法 In [21]: testList = [x+2 for x in range(5)] In [22]: testList Out[22]: [2, 3, 4, 5, 6] map函数 map函数会根据提供的函数对指定序列做映射 map(...) map(function, sequence[, sequence, ...]) -> list function:是一个函数 sequence:是一个或多个序列,取决于function需要几个参数 返回值是一个list 参数序列中的每一个元素分别调用function函数，返回包含每次function函数返回值的list。 #函数需要一个参数 map(lambda x: x*x, [1, 2, 3]) #结果为:[1, 4, 9] #函数需要两个参数 map(lambda x, y: x+y, [1, 2, 3], [4, 5, 6]) #结果为:[5, 7, 9] def f1( x, y ): return (x,y) l1 = [ 0, 1, 2, 3, 4, 5, 6 ] l2 = [ 'Sun', 'M', 'T', 'W', 'T', 'F', 'S' ] l3 = map( f1, l1, l2 ) print(list(l3)) #结果为:[(0, 'Sun'), (1, 'M'), (2, 'T'), (3, 'W'), (4, 'T'), (5, 'F'), (6, 'S')] filter函数 filter函数会对指定序列执行过滤操作 filter(...) filter(function or None, sequence) -> list, tuple, or string Return those items of sequence for which function(item) is true. If function is None, return the items that are true. If sequence is a tuple or string, return the same type, else return a list. function:接受一个参数，返回布尔值True或False sequence:序列可以是str，tuple，list filter函数会对序列参数sequence中的每个元素调用function函数，最后返回的结果包含调用结果为True的元素。 返回值的类型和参数sequence的类型相同 filter(lambda x: x%2, [1, 2, 3, 4]) [1, 3] filter(None, \"she\") 'she' reduce函数 reduce函数，reduce函数会对参数序列中元素进行累积 reduce(...) reduce(function, sequence[, initial]) -> value Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). If initial is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty. function:该函数有两个参数 sequence:序列可以是str，tuple，list initial:固定初始值 reduce依次从sequence中取一个元素，和上一次调用function的结果做参数再次调用function。 第一次调用function时，如果提供initial参数，会以sequence中的第一个元素和initial 作为参数调用function，否则会以序列sequence中的前两个元素做参数调用function。 注意function函数不能为None。 reduce(lambda x, y: x+y, [1,2,3,4]) 10 reduce(lambda x, y: x+y, [1,2,3,4], 5) 15 reduce(lambda x, y: x+y, ['aa', 'bb', 'cc'], 'dd') 'ddaabbcc' 在Python3里,reduce函数已经被从全局名字空间里移除了, 它现在被放置在fucntools模块里用的话要先引入：from functools import reduce sorted函数 sorted(...) sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list "},"primary/zhi-shi-dian-shi-yi/ji-he-set.html":{"url":"primary/zhi-shi-dian-shi-yi/ji-he-set.html","title":"集合set","keywords":"","body":"集合set 集合set 集合与之前列表、元组类似，可以存储多个数据，但是这些数据是不重复的 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric_difference(对称差集)等数学运算. >>> x = set('abcd') >>> x {'c', 'a', 'b', 'd'} >>> type(x) >>> >>> >>> y = set(['h','e','l','l','o']) >>> y {'h', 'e', 'o', 'l'} >>> >>> >>> z = set('spam') >>> z {'s', 'a', 'm', 'p'} >>> >>> >>> y&z #交集 set() >>> >>> >>> x&z #交集 {'a'} >>> >>> >>> x|y #并集 {'a', 'e', 'd', 'l', 'c', 'h', 'o', 'b'} >>> >>> x-y #差集 {'c', 'a', 'b', 'd'} >>> >>> >>> x^z #对称差集(在x或z中，但不会同时出现在二者中) {'m', 'd', 's', 'c', 'b', 'p'} >>> >>> >>> len(x) 4 >>> len(y) 4 >>> len(z) 4 >>> "},"primary/zhi-shi-dian-shi-yi/functools.html":{"url":"primary/zhi-shi-dian-shi-yi/functools.html","title":"functools","keywords":"","body":"functools functools functools 是python2.5被引人的,一些工具函数放在此包里。 python2.7中 python3.5中 import functools dir(functools) 运行结果： ['MappingProxyType', 'RLock', 'WRAPPER_ASSIGNMENTS', 'WRAPPER_UPDATES', 'WeakKeyDictionary', '_CacheInfo', '_HashedSeq', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_c3_merge', '_c3_mro', '_compose_mro', '_convert', '_find_impl', '_ge_from_gt', '_ge_from_le', '_ge_from_lt', '_gt_from_ge', '_gt_from_le', '_gt_from_lt', '_le_from_ge', '_le_from_gt', '_le_from_lt', '_lru_cache_wrapper', '_lt_from_ge', '_lt_from_gt', '_lt_from_le', '_make_key', 'cmp_to_key', 'get_cache_token', 'lru_cache', 'namedtuple', 'partial', 'partialmethod', 'reduce', 'singledispatch', 'total_ordering', 'update_wrapper', 'wraps'] python3中增加了更多工具函数，做业务开发时大多情况下用不到，此处介绍使用频率较高的2个函数。 partial函数(偏函数) 把一个函数的某些参数设置默认值，返回一个新的函数，调用这个新函数会更简单。 import functools def showarg(*args, **kw): print(args) print(kw) p1=functools.partial(showarg, 1,2,3) p1() p1(4,5,6) p1(a='python', b='itcast') p2=functools.partial(showarg, a=3,b='linux') p2() p2(1,2) p2(a='python', b='itcast') wraps函数 使用装饰器时，有一些细节需要被注意。例如，被装饰后的函数其实已经是另外一个函数了（函数名等函数属性会发生改变）。 添加后由于函数名和函数的doc发生了改变，对测试结果有一些影响，例如: def note(func): \"note function\" def wrapper(): \"wrapper function\" print('note something') return func() return wrapper @note def test(): \"test function\" print('I am test') test() print(test.__doc__) 运行结果 note something I am test wrapper function 所以，Python的functools包中提供了一个叫wraps的装饰器来消除这样的副作用。例如： import functools def note(func): \"note function\" @functools.wraps(func) def wrapper(): \"wrapper function\" print('note something') return func() return wrapper @note def test(): \"test function\" print('I am test') test() print(test.__doc__) 运行结果 note something I am test test function "},"primary/zhi-shi-dian-shi-yi/mo-kuai-jin-jie.html":{"url":"primary/zhi-shi-dian-shi-yi/mo-kuai-jin-jie.html","title":"模块进阶","keywords":"","body":"模块进阶 模块进阶 Python有一套很有用的标准库(standard library)。标准库会随着Python解释器，一起安装在你的电脑中的。 它是Python的一个组成部分。这些标准库是Python为你准备好的利器，可以让编程事半功倍。 常用标准库 标准库 说明 builtins 内建函数默认加载 os 操作系统接口 sys Python自身的运行环境 functools 常用的工具 json 编码和解码 JSON 对象 logging 记录日志，调试 multiprocessing 多进程 threading 多线程 copy 拷贝 time 时间 datetime 日期和时间 calendar 日历 hashlib 加密算法 random 生成随机数 re 字符串正则匹配 socket 标准的 BSD Sockets API shutil 文件和目录管理 glob 基于文件通配符搜索 hashlib import hashlib m = hashlib.md5() #创建hash对象，md5:(message-Digest Algorithm 5)消息摘要算法,得出一个128位的密文 print m # m.update('itcast') #更新哈希对象以字符串参数 print m.hexdigest() #返回十六进制数字字符串 应用实例 用于注册、登录.... import hashlib import datetime KEY_VALUE = 'Itcast' now = datetime.datetime.now() m = hashlib.md5() str = '%s%s' % (KEY_VALUE,now.strftime(\"%Y%m%d\")) m.update(str.encode('utf-8')) value = m.hexdigest() print(value) 运行结果: 8ad2d682e3529dac50e586fee8dc05c0 更多标准库 http://python.usyiyi.cn/translate/python_352/library/index.html 常用扩展库 扩展库 说明 requests 使用的是 urllib3，继承了urllib2的所有特性 urllib 基于http的高层库 scrapy 爬虫 beautifulsoup4 HTML/XML的解析器 celery 分布式任务调度模块 redis 缓存 Pillow(PIL) 图像处理 xlsxwriter 仅写excle功能,支持xlsx xlwt 仅写excle功能,支持xls ,2013或更早版office xlrd 仅读excle功能 elasticsearch 全文搜索引擎 pymysql 数据库连接库 mongoengine/pymongo mongodbpython接口 matplotlib 画图 numpy/scipy 科学计算 django/tornado/flask web框架 xmltodict xml 转 dict SimpleHTTPServer 简单地HTTP Server,不使用Web框架 gevent 基于协程的Python网络库 fabric 系统管理 pandas 数据处理库 scikit-learn 机器学习库 就可以运行起来静态服务。平时用它预览和下载文件太方便了。 在终端中输入命令： python2中 python -m SimpleHTTPServer PORT python3中 python -m http.server PORT 读写excel文件 1.安装个easy_install工具 sudo apt-get install python-setuptools 2.安装模块 sudo easy_install xlrd sudo easy_install xlwt matplotlib "},"primary/zhi-shi-dian-shi-yi/diao-shi.html":{"url":"primary/zhi-shi-dian-shi-yi/diao-shi.html","title":"调试","keywords":"","body":"调试 pdb 执行时调试 交互调试 程序里埋点 日志调试 print大法好 调试 pdb pdb是基于命令行的调试工具，非常类似gnu的gdb（调试c/c++）。 命令 简写命令 作用 break b 设置断点 continue c 继续执行程序 list l 查看当前行的代码段 step s 进入函数 return r 执行代码直到从当前函数返回 quit q 中止并退出 next n 执行下一行 print p 打印变量的值 help h 帮助 args a 查看传入参数 回车 重复上一条命令 break b 显示所有断点 break lineno b lineno 在指定行设置断点 break file:lineno b file:lineno 在指定文件的行设置断点 clear num 删除指定断点 bt 查看函数调用栈帧 执行时调试 程序启动，停止在第一行等待单步调试。 python -m pdb some.py 交互调试 进入python或ipython解释器 import pdb pdb.run('testfun(args)') #此时会打开pdb调试，注意：先使用s跳转到这个testfun函数中，然后就可以使用l看到代码了 程序里埋点 当程序执行到pdb.set_trace() 位置时停下来调试 代码上下文 ... import pdb pdb.set_trace() ... 日志调试 print大法好 使用pdb调试的5个demo demo 1 import pdb a = \"aaa\" pdb.set_trace() b = \"bbb\" c = \"ccc\" final = a + b + c print final #调试方法 # 《1 显示代码》 # l---->能够显示当前调试过程中的代码，其实l表示list列出的意思 #如下，途中，-> 指向的地方表示要将要执行的位置 # 2 a = \"aaa\" # 3 pdb.set_trace() # 4 b = \"bbb\" # 5 c = \"ccc\" # 6 pdb.set_trace() # 7 -> final = a + b + c # 8 print final # 《2 执行下一行代码》 # n---->能够向下执行一行代码，然后停止运行等待继续调试 n表示next的意思 # 《3 查看变量的值》 # p---->能够查看变量的值，p表示prit打印输出的意思 #例如： # p name 表示查看变量name的值 demo 2 import pdb a = \"aaa\" pdb.set_trace() b = \"bbb\" c = \"ccc\" pdb.set_trace() final = a + b + c print final # 《4 将程序继续运行》 # c----->让程序继续向下执行，与n的区别是n只会执行下面的一行代码，而c会像python xxxx.py一样 继续执行不会停止；c表示continue的意思 # 《5 set_trace()》 # 如果程序中有多个set_trace()，那么能够让程序在使用c的时候停留在下一个set_trace()位置处 demo 3 #coding=utf-8 import pdb def combine(s1,s2): s3 = s1 + s2 + s1 s3 = '\"' + s3 +'\"' return s3 a = \"aaa\" pdb.set_trace() b = \"bbb\" c = \"ccc\" final = combine(a,b) print final # 《6 设置断点》 # b---->设置断点，即当使用c的时候，c可以在遇到set_trace()的时候停止，也可以在遇到标记有断点的地方停止；b表示break的意思 #例如： #b 11 在第11行设置断点，注意这个11可以使用l来得到 # (Pdb) l # 4 s3 = s1 + s2 + s1 # 5 s3 = '\"' + s3 +'\"' # 6 return s3 # 7 a = \"aaa\" # 8 pdb.set_trace() # 9 -> b = \"bbb\" # 10 c = \"ccc\" # 11 final = combine(a,b) # 12 print final # [EOF] # (Pdb) b 11 # Breakpoint 1 at /Users/wangmingdong/Desktop/test3.py:11 # (Pdb) c # > /Users/wangmingdong/Desktop/test3.py(11)() # -> final = combine(a,b) # (Pdb) l # 6 return s3 # 7 a = \"aaa\" # 8 pdb.set_trace() # 9 b = \"bbb\" # 10 c = \"ccc\" # 11 B-> final = combine(a,b) # 12 print final # 《7 进入函数继续调试》 # s---->进入函数里面继续调试，如果使用n表示把一个函数的调用当做一条语句执行过去，而使用s的话，会进入到这个函数 并且停止 #例如 # (Pdb) l # 6 return s3 # 7 a = \"aaa\" # 8 pdb.set_trace() # 9 b = \"bbb\" # 10 c = \"ccc\" # 11 B-> final = combine(a,b) # 12 print final # [EOF] # (Pdb) s # --Call-- # > /Users/wangmingdong/Desktop/test3.py(3)combine() # -> def combine(s1,s2): # (Pdb) l # 1 import pdb # 2 # 3 -> def combine(s1,s2): # 4 s3 = s1 + s2 + s1 # 5 s3 = '\"' + s3 +'\"' # 6 return s3 # 7 a = \"aaa\" # 8 pdb.set_trace() # 9 b = \"bbb\" # 10 c = \"ccc\" # 11 B final = combine(a,b) # (Pdb) # 《8 查看传递到函数中的变量》 # a---->调用一个函数时，可以查看传递到这个函数中的所有的参数；a表示arg的意思 #例如： # (Pdb) l # 1 #coding=utf-8 # 2 import pdb # 3 # 4 -> def combine(s1,s2): # 5 s3 = s1 + s2 + s1 # 6 s3 = '\"' + s3 +'\"' # 7 return s3 # 8 # 9 a = \"aaa\" # 10 pdb.set_trace() # 11 b = \"bbb\" # (Pdb) a # s1 = aaa # s2 = bbb # 《9 执行到函数的最后一步》 # r----->如果在函数中不想一步步的调试了，只是想到这个函数的最后一条语句那个位置，比如return语句，那么就可以使用r；r表示return的意思 demo 4 In [1]: def pdb_test(arg): ...: for i in range(arg): ...: print(i) ...: return arg ...: In [2]: #在python交互模式中，如果想要调试这个函数，那么可以 In [3]: #采用，pdb.run的方式，如下： In [4]: import pdb In [5]: pdb.run(\"pdb_test(10)\") > (1)() (Pdb) s --Call-- > (1)pdb_test() -> def pdb_test(arg): (Pdb) l 1 -> def pdb_test(arg): 2 for i in range(arg): 3 print(i) 4 return arg [EOF] (Pdb) n > (2)pdb_test() -> for i in range(arg): (Pdb) l 1 def pdb_test(arg): 2 -> for i in range(arg): 3 print(i) 4 return arg [EOF] (Pdb) n > (3)pdb_test() -> print(i) (Pdb) 0 > (2)pdb_test() -> for i in range(arg): (Pdb) > (3)pdb_test() -> print(i) (Pdb) 1 > (2)pdb_test() -> for i in range(arg): (Pdb) demo 5 运行过程中使用pdb修改变量的值 In [7]: pdb.run(\"pdb_test(1)\") > (1)() (Pdb) s --Call-- > (1)pdb_test() -> def pdb_test(arg): (Pdb) a arg = 1 (Pdb) l 1 -> def pdb_test(arg): 2 for i in range(arg): 3 print(i) 4 return arg [EOF] (Pdb) !arg = 100 #!!!这里是修改变量的方法 (Pdb) n > (2)pdb_test() -> for i in range(arg): (Pdb) l 1 def pdb_test(arg): 2 -> for i in range(arg): 3 print(i) 4 return arg [EOF] (Pdb) p arg 100 (Pdb) 练一练:请使用所学的pdb调试技巧对其进行调试出bug #coding=utf-8 import pdb def add3Nums(a1,a2,a3): result = a1+a2+a3 return result def get3NumsAvarage(s1,s2): s3 = s1 + s2 + s1 result = 0 result = add3Nums(s1,s2,s3)/3 if __name__ == '__main__': a = 11 # pdb.set_trace() b = 12 final = get3NumsAvarage(a,b) print final pdb 调试有个明显的缺陷就是对于多线程，远程调试等支持得不够好，同时没有较为直观的界面显示，不太适合大型的 python 项目。而在较大的 python 项目中，这些调试需求比较常见，因此需要使用更为高级的调试工具。 "},"primary/zhi-shi-dian-shi-yi/bian-ma-feng-ge.html":{"url":"primary/zhi-shi-dian-shi-yi/bian-ma-feng-ge.html","title":"编码风格","keywords":"","body":"编码风格 编码风格 错误认知 这很浪费时间 我是个艺术家 所有人都能穿的鞋不会合任何人的脚 我善长制定编码规范 正确认知 促进团队合作 减少bug处理 提高可读性，降低维护成本 有助于代码审查 养成习惯，有助于程序员自身的成长 pep8 编码规范 Python Enhancement Proposals ：python改进方案 https://www.python.org/dev/peps/ pep8 官网规范地址 https://www.python.org/dev/peps/pep-0008/ Guido的关键点之一是：代码更多是用来读而不是写。编码规范旨在改善Python代码的可读性。 风格指南强调一致性。项目、模块或函数保持一致都很重要。 每级缩进用4个空格。 括号中使用垂直隐式缩进或使用悬挂缩进。后者应该注意第一行要没有参数，后续行要有缩进。 Yes # 对准左括号 foo = long_function_name(var_one, var_two, var_three, var_four) # 不对准左括号，但加多一层缩进，以和后面内容区别。 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # 悬挂缩进必须加多一层缩进. foo = long_function_name( var_one, var_two, var_three, var_four) No # 不使用垂直对齐时，第一行不能有参数。 foo = long_function_name(var_one, var_two, var_three, var_four) # 参数的缩进和后续内容缩进不能区别。 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) 4个空格的规则是对续行可选的。 # 悬挂缩进不一定是4个空格 foo = long_function_name( var_one, var_two, var_three, var_four) if语句跨行时，两个字符关键字(比如if)加上一个空格，再加上左括号构成了很好的缩进。后续行暂时没有规定，至少有如下三种格式，建议使用第3种。 # 没有额外缩进，不是很好看，个人不推荐. if (this_is_one_thing and that_is_another_thing): do_something() # 添加注释 if (this_is_one_thing and that_is_another_thing): # Since both conditions are true, we can frobnicate. do_something() # 额外添加缩进,推荐。 # Add some extra indentation on the conditional continuation line. if (this_is_one_thing and that_is_another_thing): do_something() 右边括号也可以另起一行。有两种格式，建议第2种。 # 右括号不回退，个人不推荐 my_list = [ 1, 2, 3, 4, 5, 6, ] result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) # 右括号回退 my_list = [ 1, 2, 3, 4, 5, 6, ] result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) 空格或Tab? 空格是首选的缩进方法。 Tab仅仅在已经使用tab缩进的代码中为了保持一致性而使用。 Python 3中不允许混合使用Tab和空格缩进。 Python 2的包含空格与Tab和空格缩进的应该全部转为空格缩进。 最大行宽 限制所有行的最大行宽为79字符。 文本长块，比如文档字符串或注释，行长度应限制为72个字符。 空行 两行空行分割顶层函数和类的定义。 类的方法定义用单个空行分割。 额外的空行可以必要的时候用于分割不同的函数组，但是要尽量节约使用。 额外的空行可以必要的时候在函数中用于分割不同的逻辑块，但是要尽量节约使用。 源文件编码 在核心Python发布的代码应该总是使用UTF-8(ASCII在Python 2)。 Python 3(默认UTF-8)不应有编码声明。 导入在单独行 Yes： import os import sys from subprocess import Popen, PIPE No: import sys, os 导入始终在文件的顶部，在模块注释和文档字符串之后，在模块全局变量和常量之前。 导入顺序如下：标准库进口,相关的第三方库，本地库。各组的导入之间要有空行。 禁止使用通配符导入。 通配符导入(fromimport *)应该避免，因为它不清楚命名空间有哪些名称存，混淆读者和许多自动化的工具。 字符串引用 Python中单引号字符串和双引号字符串都是相同的。注意尽量避免在字符串中的反斜杠以提高可读性。 根据PEP 257, 三个引号都使用双引号。 括号里边避免空格 # 括号里边避免空格 # Yes spam(ham[1], {eggs: 2}) # No spam( ham[ 1 ], { eggs: 2 } ) 逗号，冒号，分号之前避免空格 # 逗号，冒号，分号之前避免空格 # Yes if x == 4: print x, y; x, y = y, x # No if x == 4 : print x , y ; x , y = y , x 索引操作中的冒号当作操作符处理前后要有同样的空格(一个空格或者没有空格，个人建议是没有。) # Yes ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:] ham[lower:upper], ham[lower:upper:], ham[lower::step] ham[lower+offset : upper+offset] ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)] ham[lower + offset : upper + offset] # No ham[lower + offset:upper + offset] ham[1: 9], ham[1 :9], ham[1:9 :3] ham[lower : : upper] ham[ : upper] 函数调用的左括号之前不能有空格 # Yes spam(1) dct['key'] = lst[index] # No spam (1) dct ['key'] = lst [index] 赋值等操作符前后不能因为对齐而添加多个空格 # Yes x = 1 y = 2 long_variable = 3 # No x = 1 y = 2 long_variable = 3 二元运算符两边放置一个空格 涉及 =、符合操作符 ( += , -=等)、比较( == , , != , <> , = , in , not in , is , is not )、布尔( and , or , not )。 优先级高的运算符或操作符的前后不建议有空格。 # Yes i = i + 1 submitted += 1 x = x*2 - 1 hypot2 = x*x + y*y c = (a+b) * (a-b) # No i=i+1 submitted +=1 x = x * 2 - 1 hypot2 = x * x + y * y c = (a + b) * (a - b) 关键字参数和默认值参数的前后不要加空格 # Yes def complex(real, imag=0.0): return magic(r=real, i=imag) # No def complex(real, imag = 0.0): return magic(r = real, i = imag) 通常不推荐复合语句(Compound statements: 多条语句写在同一行)。 # Yes if foo == 'blah': do_blah_thing() do_one() do_two() do_three() # No if foo == 'blah': do_blah_thing() do_one(); do_two(); do_three() 尽管有时可以在if/for/while 的同一行跟一小段代码，但绝不要跟多个子句，并尽量避免换行。 # No if foo == 'blah': do_blah_thing() for x in lst: total += x while t 避免采用的名字 决不要用字符'l'(小写字母el)，'O'(大写字母oh)，或 'I'(大写字母eye) 作为单个字符的变量名。一些字体中，这些字符不能与数字1和0区别。用'L' 代替'l'时。 包和模块名 模块名要简短，全部用小写字母，可使用下划线以提高可读性。包名和模块名类似，但不推荐使用下划线。 "}}